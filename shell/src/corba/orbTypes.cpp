// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.

#include "orbTypes.h"
#include <omniORB4/IOP_S.h>
#include <omniORB4/IOP_C.h>
#include <omniORB4/callDescriptor.h>
#include <omniORB4/callHandle.h>
#include <omniORB4/objTracker.h>


OMNI_USING_NAMESPACE(omni)

static const char* _0RL_library_version = omniORB_4_1;



STI::Types::TAttributeSeq::TAttributeSeq(const ::STI::Types::TAttributeSeq& _s)
  : _CORBA_Unbounded_Sequence_Forward< STI::Types::TAttribute > (_s.pd_max, 0, 0, 1)
{
  length(_s.pd_len);
  for (_CORBA_ULong _i=0; _i < pd_len; _i++) {
    pd_buf[_i] = _s.pd_buf[_i];
  }
}

void
STI::Types::TAttributeSeq::operator<<= (cdrStream& _s)
{
  _CORBA_ULong _l;
  _l <<= _s;
  if (!_s.checkInputOverrun(1,_l)) {
    _CORBA_marshal_sequence_range_check_error(_s);
    // never reach here
  }
  length(_l);
  for( _CORBA_ULong _i = 0; _i < _l; _i++ )
    pd_buf[_i] <<= _s;
}

void
STI::Types::TAttributeSeq::operator>>= (cdrStream& _s) const
{
  ::operator>>=(_CORBA_ULong(pd_len), _s);
  for( _CORBA_ULong _i = 0; _i < pd_len; _i++ )
    pd_buf[_i] >>= _s;
}

STI::Types::TAttributeSeq&
STI::Types::TAttributeSeq::operator=(const ::STI::Types::TAttributeSeq& _s)
{
  length(_s.pd_len);
  for (unsigned long _i=0; _i < pd_len; _i++) {
    pd_buf[_i] = _s.pd_buf[_i];
  }
  return *this;
}

STI::Types::TAttribute&
STI::Types::TAttributeSeq::operator[](_CORBA_ULong _index)
{
  if (_index >= pd_len) _CORBA_bound_check_error();
  return pd_buf[_index];
}

const STI::Types::TAttribute&
STI::Types::TAttributeSeq::operator[](_CORBA_ULong _index) const
{
  if (_index >= pd_len) _CORBA_bound_check_error();
  return pd_buf[_index];
}

STI::Types::TAttribute*
STI::Types::TAttributeSeq::allocbuf(_CORBA_ULong _nelems)
{
  ::STI::Types::TAttribute* _tmp = 0;
  if (_nelems) {
    _tmp = new ::STI::Types::TAttribute[_nelems];
  }
  return _tmp;
}

void
STI::Types::TAttributeSeq::freebuf(::STI::Types::TAttribute* _b)
{
  if (_b) delete [] _b;
}

void
STI::Types::TAttributeSeq::NP_freebuf()
{
  if (pd_buf) delete [] pd_buf;
}

STI::Types::TAttributeSeq::~TAttributeSeq()
{
  if (pd_rel && pd_buf) delete [] pd_buf;
  pd_buf = 0;
}

void
STI::Types::TAttributeSeq::NP_copybuffer(_CORBA_ULong _newmax)
{
  // replace pd_data with a new buffer of size newmax.
  // Invariant:  pd_len <= newmax
  //
  ::STI::Types::TAttribute* _newbuf = allocbuf(_newmax);
  if (!_newbuf) {
    _CORBA_new_operator_return_null();
    // never reach here
  }
  for (unsigned long _i=0; _i < pd_len; _i++) {
    _newbuf[_i] = pd_buf[_i];
  }
  if (pd_rel && pd_buf) {
    freebuf(pd_buf);
  }
  else {
    pd_rel = 1;
  }
  pd_buf = _newbuf;
  pd_max = _newmax;
}

STI::Types::TChannelSeq::TChannelSeq(const ::STI::Types::TChannelSeq& _s)
  : _CORBA_Unbounded_Sequence_Forward< STI::Types::TChannel > (_s.pd_max, 0, 0, 1)
{
  length(_s.pd_len);
  for (_CORBA_ULong _i=0; _i < pd_len; _i++) {
    pd_buf[_i] = _s.pd_buf[_i];
  }
}

void
STI::Types::TChannelSeq::operator<<= (cdrStream& _s)
{
  _CORBA_ULong _l;
  _l <<= _s;
  if (!_s.checkInputOverrun(1,_l)) {
    _CORBA_marshal_sequence_range_check_error(_s);
    // never reach here
  }
  length(_l);
  for( _CORBA_ULong _i = 0; _i < _l; _i++ )
    pd_buf[_i] <<= _s;
}

void
STI::Types::TChannelSeq::operator>>= (cdrStream& _s) const
{
  ::operator>>=(_CORBA_ULong(pd_len), _s);
  for( _CORBA_ULong _i = 0; _i < pd_len; _i++ )
    pd_buf[_i] >>= _s;
}

STI::Types::TChannelSeq&
STI::Types::TChannelSeq::operator=(const ::STI::Types::TChannelSeq& _s)
{
  length(_s.pd_len);
  for (unsigned long _i=0; _i < pd_len; _i++) {
    pd_buf[_i] = _s.pd_buf[_i];
  }
  return *this;
}

STI::Types::TChannel&
STI::Types::TChannelSeq::operator[](_CORBA_ULong _index)
{
  if (_index >= pd_len) _CORBA_bound_check_error();
  return pd_buf[_index];
}

const STI::Types::TChannel&
STI::Types::TChannelSeq::operator[](_CORBA_ULong _index) const
{
  if (_index >= pd_len) _CORBA_bound_check_error();
  return pd_buf[_index];
}

STI::Types::TChannel*
STI::Types::TChannelSeq::allocbuf(_CORBA_ULong _nelems)
{
  ::STI::Types::TChannel* _tmp = 0;
  if (_nelems) {
    _tmp = new ::STI::Types::TChannel[_nelems];
  }
  return _tmp;
}

void
STI::Types::TChannelSeq::freebuf(::STI::Types::TChannel* _b)
{
  if (_b) delete [] _b;
}

void
STI::Types::TChannelSeq::NP_freebuf()
{
  if (pd_buf) delete [] pd_buf;
}

STI::Types::TChannelSeq::~TChannelSeq()
{
  if (pd_rel && pd_buf) delete [] pd_buf;
  pd_buf = 0;
}

void
STI::Types::TChannelSeq::NP_copybuffer(_CORBA_ULong _newmax)
{
  // replace pd_data with a new buffer of size newmax.
  // Invariant:  pd_len <= newmax
  //
  ::STI::Types::TChannel* _newbuf = allocbuf(_newmax);
  if (!_newbuf) {
    _CORBA_new_operator_return_null();
    // never reach here
  }
  for (unsigned long _i=0; _i < pd_len; _i++) {
    _newbuf[_i] = pd_buf[_i];
  }
  if (pd_rel && pd_buf) {
    freebuf(pd_buf);
  }
  else {
    pd_rel = 1;
  }
  pd_buf = _newbuf;
  pd_max = _newmax;
}

STI::Types::TDataMixedSeq::TDataMixedSeq(const ::STI::Types::TDataMixedSeq& _s)
  : _CORBA_Unbounded_Sequence_Forward< STI::Types::TDataMixed > (_s.pd_max, 0, 0, 1)
{
  length(_s.pd_len);
  for (_CORBA_ULong _i=0; _i < pd_len; _i++) {
    pd_buf[_i] = _s.pd_buf[_i];
  }
}

void
STI::Types::TDataMixedSeq::operator<<= (cdrStream& _s)
{
  _CORBA_ULong _l;
  _l <<= _s;
  if (!_s.checkInputOverrun(1,_l)) {
    _CORBA_marshal_sequence_range_check_error(_s);
    // never reach here
  }
  length(_l);
  for( _CORBA_ULong _i = 0; _i < _l; _i++ )
    pd_buf[_i] <<= _s;
}

void
STI::Types::TDataMixedSeq::operator>>= (cdrStream& _s) const
{
  ::operator>>=(_CORBA_ULong(pd_len), _s);
  for( _CORBA_ULong _i = 0; _i < pd_len; _i++ )
    pd_buf[_i] >>= _s;
}

STI::Types::TDataMixedSeq&
STI::Types::TDataMixedSeq::operator=(const ::STI::Types::TDataMixedSeq& _s)
{
  length(_s.pd_len);
  for (unsigned long _i=0; _i < pd_len; _i++) {
    pd_buf[_i] = _s.pd_buf[_i];
  }
  return *this;
}

STI::Types::TDataMixed&
STI::Types::TDataMixedSeq::operator[](_CORBA_ULong _index)
{
  if (_index >= pd_len) _CORBA_bound_check_error();
  return pd_buf[_index];
}

const STI::Types::TDataMixed&
STI::Types::TDataMixedSeq::operator[](_CORBA_ULong _index) const
{
  if (_index >= pd_len) _CORBA_bound_check_error();
  return pd_buf[_index];
}

STI::Types::TDataMixed*
STI::Types::TDataMixedSeq::allocbuf(_CORBA_ULong _nelems)
{
  ::STI::Types::TDataMixed* _tmp = 0;
  if (_nelems) {
    _tmp = new ::STI::Types::TDataMixed[_nelems];
  }
  return _tmp;
}

void
STI::Types::TDataMixedSeq::freebuf(::STI::Types::TDataMixed* _b)
{
  if (_b) delete [] _b;
}

void
STI::Types::TDataMixedSeq::NP_freebuf()
{
  if (pd_buf) delete [] pd_buf;
}

STI::Types::TDataMixedSeq::~TDataMixedSeq()
{
  if (pd_rel && pd_buf) delete [] pd_buf;
  pd_buf = 0;
}

void
STI::Types::TDataMixedSeq::NP_copybuffer(_CORBA_ULong _newmax)
{
  // replace pd_data with a new buffer of size newmax.
  // Invariant:  pd_len <= newmax
  //
  ::STI::Types::TDataMixed* _newbuf = allocbuf(_newmax);
  if (!_newbuf) {
    _CORBA_new_operator_return_null();
    // never reach here
  }
  for (unsigned long _i=0; _i < pd_len; _i++) {
    _newbuf[_i] = pd_buf[_i];
  }
  if (pd_rel && pd_buf) {
    freebuf(pd_buf);
  }
  else {
    pd_rel = 1;
  }
  pd_buf = _newbuf;
  pd_max = _newmax;
}

STI::Types::TDeviceSeq::TDeviceSeq(const ::STI::Types::TDeviceSeq& _s)
  : _CORBA_Unbounded_Sequence_Forward< STI::Types::TDevice > (_s.pd_max, 0, 0, 1)
{
  length(_s.pd_len);
  for (_CORBA_ULong _i=0; _i < pd_len; _i++) {
    pd_buf[_i] = _s.pd_buf[_i];
  }
}

void
STI::Types::TDeviceSeq::operator<<= (cdrStream& _s)
{
  _CORBA_ULong _l;
  _l <<= _s;
  if (!_s.checkInputOverrun(1,_l)) {
    _CORBA_marshal_sequence_range_check_error(_s);
    // never reach here
  }
  length(_l);
  for( _CORBA_ULong _i = 0; _i < _l; _i++ )
    pd_buf[_i] <<= _s;
}

void
STI::Types::TDeviceSeq::operator>>= (cdrStream& _s) const
{
  ::operator>>=(_CORBA_ULong(pd_len), _s);
  for( _CORBA_ULong _i = 0; _i < pd_len; _i++ )
    pd_buf[_i] >>= _s;
}

STI::Types::TDeviceSeq&
STI::Types::TDeviceSeq::operator=(const ::STI::Types::TDeviceSeq& _s)
{
  length(_s.pd_len);
  for (unsigned long _i=0; _i < pd_len; _i++) {
    pd_buf[_i] = _s.pd_buf[_i];
  }
  return *this;
}

STI::Types::TDevice&
STI::Types::TDeviceSeq::operator[](_CORBA_ULong _index)
{
  if (_index >= pd_len) _CORBA_bound_check_error();
  return pd_buf[_index];
}

const STI::Types::TDevice&
STI::Types::TDeviceSeq::operator[](_CORBA_ULong _index) const
{
  if (_index >= pd_len) _CORBA_bound_check_error();
  return pd_buf[_index];
}

STI::Types::TDevice*
STI::Types::TDeviceSeq::allocbuf(_CORBA_ULong _nelems)
{
  ::STI::Types::TDevice* _tmp = 0;
  if (_nelems) {
    _tmp = new ::STI::Types::TDevice[_nelems];
  }
  return _tmp;
}

void
STI::Types::TDeviceSeq::freebuf(::STI::Types::TDevice* _b)
{
  if (_b) delete [] _b;
}

void
STI::Types::TDeviceSeq::NP_freebuf()
{
  if (pd_buf) delete [] pd_buf;
}

STI::Types::TDeviceSeq::~TDeviceSeq()
{
  if (pd_rel && pd_buf) delete [] pd_buf;
  pd_buf = 0;
}

void
STI::Types::TDeviceSeq::NP_copybuffer(_CORBA_ULong _newmax)
{
  // replace pd_data with a new buffer of size newmax.
  // Invariant:  pd_len <= newmax
  //
  ::STI::Types::TDevice* _newbuf = allocbuf(_newmax);
  if (!_newbuf) {
    _CORBA_new_operator_return_null();
    // never reach here
  }
  for (unsigned long _i=0; _i < pd_len; _i++) {
    _newbuf[_i] = pd_buf[_i];
  }
  if (pd_rel && pd_buf) {
    freebuf(pd_buf);
  }
  else {
    pd_rel = 1;
  }
  pd_buf = _newbuf;
  pd_max = _newmax;
}

STI::Types::TDeviceChannelSeq::TDeviceChannelSeq(const ::STI::Types::TDeviceChannelSeq& _s)
  : _CORBA_Unbounded_Sequence_Forward< STI::Types::TDeviceChannel > (_s.pd_max, 0, 0, 1)
{
  length(_s.pd_len);
  for (_CORBA_ULong _i=0; _i < pd_len; _i++) {
    pd_buf[_i] = _s.pd_buf[_i];
  }
}

void
STI::Types::TDeviceChannelSeq::operator<<= (cdrStream& _s)
{
  _CORBA_ULong _l;
  _l <<= _s;
  if (!_s.checkInputOverrun(1,_l)) {
    _CORBA_marshal_sequence_range_check_error(_s);
    // never reach here
  }
  length(_l);
  for( _CORBA_ULong _i = 0; _i < _l; _i++ )
    pd_buf[_i] <<= _s;
}

void
STI::Types::TDeviceChannelSeq::operator>>= (cdrStream& _s) const
{
  ::operator>>=(_CORBA_ULong(pd_len), _s);
  for( _CORBA_ULong _i = 0; _i < pd_len; _i++ )
    pd_buf[_i] >>= _s;
}

STI::Types::TDeviceChannelSeq&
STI::Types::TDeviceChannelSeq::operator=(const ::STI::Types::TDeviceChannelSeq& _s)
{
  length(_s.pd_len);
  for (unsigned long _i=0; _i < pd_len; _i++) {
    pd_buf[_i] = _s.pd_buf[_i];
  }
  return *this;
}

STI::Types::TDeviceChannel&
STI::Types::TDeviceChannelSeq::operator[](_CORBA_ULong _index)
{
  if (_index >= pd_len) _CORBA_bound_check_error();
  return pd_buf[_index];
}

const STI::Types::TDeviceChannel&
STI::Types::TDeviceChannelSeq::operator[](_CORBA_ULong _index) const
{
  if (_index >= pd_len) _CORBA_bound_check_error();
  return pd_buf[_index];
}

STI::Types::TDeviceChannel*
STI::Types::TDeviceChannelSeq::allocbuf(_CORBA_ULong _nelems)
{
  ::STI::Types::TDeviceChannel* _tmp = 0;
  if (_nelems) {
    _tmp = new ::STI::Types::TDeviceChannel[_nelems];
  }
  return _tmp;
}

void
STI::Types::TDeviceChannelSeq::freebuf(::STI::Types::TDeviceChannel* _b)
{
  if (_b) delete [] _b;
}

void
STI::Types::TDeviceChannelSeq::NP_freebuf()
{
  if (pd_buf) delete [] pd_buf;
}

STI::Types::TDeviceChannelSeq::~TDeviceChannelSeq()
{
  if (pd_rel && pd_buf) delete [] pd_buf;
  pd_buf = 0;
}

void
STI::Types::TDeviceChannelSeq::NP_copybuffer(_CORBA_ULong _newmax)
{
  // replace pd_data with a new buffer of size newmax.
  // Invariant:  pd_len <= newmax
  //
  ::STI::Types::TDeviceChannel* _newbuf = allocbuf(_newmax);
  if (!_newbuf) {
    _CORBA_new_operator_return_null();
    // never reach here
  }
  for (unsigned long _i=0; _i < pd_len; _i++) {
    _newbuf[_i] = pd_buf[_i];
  }
  if (pd_rel && pd_buf) {
    freebuf(pd_buf);
  }
  else {
    pd_rel = 1;
  }
  pd_buf = _newbuf;
  pd_max = _newmax;
}

STI::Types::TDeviceEventSeq::TDeviceEventSeq(const ::STI::Types::TDeviceEventSeq& _s)
  : _CORBA_Unbounded_Sequence_Forward< STI::Types::TDeviceEvent > (_s.pd_max, 0, 0, 1)
{
  length(_s.pd_len);
  for (_CORBA_ULong _i=0; _i < pd_len; _i++) {
    pd_buf[_i] = _s.pd_buf[_i];
  }
}

void
STI::Types::TDeviceEventSeq::operator<<= (cdrStream& _s)
{
  _CORBA_ULong _l;
  _l <<= _s;
  if (!_s.checkInputOverrun(1,_l)) {
    _CORBA_marshal_sequence_range_check_error(_s);
    // never reach here
  }
  length(_l);
  for( _CORBA_ULong _i = 0; _i < _l; _i++ )
    pd_buf[_i] <<= _s;
}

void
STI::Types::TDeviceEventSeq::operator>>= (cdrStream& _s) const
{
  ::operator>>=(_CORBA_ULong(pd_len), _s);
  for( _CORBA_ULong _i = 0; _i < pd_len; _i++ )
    pd_buf[_i] >>= _s;
}

STI::Types::TDeviceEventSeq&
STI::Types::TDeviceEventSeq::operator=(const ::STI::Types::TDeviceEventSeq& _s)
{
  length(_s.pd_len);
  for (unsigned long _i=0; _i < pd_len; _i++) {
    pd_buf[_i] = _s.pd_buf[_i];
  }
  return *this;
}

STI::Types::TDeviceEvent&
STI::Types::TDeviceEventSeq::operator[](_CORBA_ULong _index)
{
  if (_index >= pd_len) _CORBA_bound_check_error();
  return pd_buf[_index];
}

const STI::Types::TDeviceEvent&
STI::Types::TDeviceEventSeq::operator[](_CORBA_ULong _index) const
{
  if (_index >= pd_len) _CORBA_bound_check_error();
  return pd_buf[_index];
}

STI::Types::TDeviceEvent*
STI::Types::TDeviceEventSeq::allocbuf(_CORBA_ULong _nelems)
{
  ::STI::Types::TDeviceEvent* _tmp = 0;
  if (_nelems) {
    _tmp = new ::STI::Types::TDeviceEvent[_nelems];
  }
  return _tmp;
}

void
STI::Types::TDeviceEventSeq::freebuf(::STI::Types::TDeviceEvent* _b)
{
  if (_b) delete [] _b;
}

void
STI::Types::TDeviceEventSeq::NP_freebuf()
{
  if (pd_buf) delete [] pd_buf;
}

STI::Types::TDeviceEventSeq::~TDeviceEventSeq()
{
  if (pd_rel && pd_buf) delete [] pd_buf;
  pd_buf = 0;
}

void
STI::Types::TDeviceEventSeq::NP_copybuffer(_CORBA_ULong _newmax)
{
  // replace pd_data with a new buffer of size newmax.
  // Invariant:  pd_len <= newmax
  //
  ::STI::Types::TDeviceEvent* _newbuf = allocbuf(_newmax);
  if (!_newbuf) {
    _CORBA_new_operator_return_null();
    // never reach here
  }
  for (unsigned long _i=0; _i < pd_len; _i++) {
    _newbuf[_i] = pd_buf[_i];
  }
  if (pd_rel && pd_buf) {
    freebuf(pd_buf);
  }
  else {
    pd_rel = 1;
  }
  pd_buf = _newbuf;
  pd_max = _newmax;
}

STI::Types::TEventSeq::TEventSeq(const ::STI::Types::TEventSeq& _s)
  : _CORBA_Unbounded_Sequence_Forward< STI::Types::TEvent > (_s.pd_max, 0, 0, 1)
{
  length(_s.pd_len);
  for (_CORBA_ULong _i=0; _i < pd_len; _i++) {
    pd_buf[_i] = _s.pd_buf[_i];
  }
}

void
STI::Types::TEventSeq::operator<<= (cdrStream& _s)
{
  _CORBA_ULong _l;
  _l <<= _s;
  if (!_s.checkInputOverrun(1,_l)) {
    _CORBA_marshal_sequence_range_check_error(_s);
    // never reach here
  }
  length(_l);
  for( _CORBA_ULong _i = 0; _i < _l; _i++ )
    pd_buf[_i] <<= _s;
}

void
STI::Types::TEventSeq::operator>>= (cdrStream& _s) const
{
  ::operator>>=(_CORBA_ULong(pd_len), _s);
  for( _CORBA_ULong _i = 0; _i < pd_len; _i++ )
    pd_buf[_i] >>= _s;
}

STI::Types::TEventSeq&
STI::Types::TEventSeq::operator=(const ::STI::Types::TEventSeq& _s)
{
  length(_s.pd_len);
  for (unsigned long _i=0; _i < pd_len; _i++) {
    pd_buf[_i] = _s.pd_buf[_i];
  }
  return *this;
}

STI::Types::TEvent&
STI::Types::TEventSeq::operator[](_CORBA_ULong _index)
{
  if (_index >= pd_len) _CORBA_bound_check_error();
  return pd_buf[_index];
}

const STI::Types::TEvent&
STI::Types::TEventSeq::operator[](_CORBA_ULong _index) const
{
  if (_index >= pd_len) _CORBA_bound_check_error();
  return pd_buf[_index];
}

STI::Types::TEvent*
STI::Types::TEventSeq::allocbuf(_CORBA_ULong _nelems)
{
  ::STI::Types::TEvent* _tmp = 0;
  if (_nelems) {
    _tmp = new ::STI::Types::TEvent[_nelems];
  }
  return _tmp;
}

void
STI::Types::TEventSeq::freebuf(::STI::Types::TEvent* _b)
{
  if (_b) delete [] _b;
}

void
STI::Types::TEventSeq::NP_freebuf()
{
  if (pd_buf) delete [] pd_buf;
}

STI::Types::TEventSeq::~TEventSeq()
{
  if (pd_rel && pd_buf) delete [] pd_buf;
  pd_buf = 0;
}

void
STI::Types::TEventSeq::NP_copybuffer(_CORBA_ULong _newmax)
{
  // replace pd_data with a new buffer of size newmax.
  // Invariant:  pd_len <= newmax
  //
  ::STI::Types::TEvent* _newbuf = allocbuf(_newmax);
  if (!_newbuf) {
    _CORBA_new_operator_return_null();
    // never reach here
  }
  for (unsigned long _i=0; _i < pd_len; _i++) {
    _newbuf[_i] = pd_buf[_i];
  }
  if (pd_rel && pd_buf) {
    freebuf(pd_buf);
  }
  else {
    pd_rel = 1;
  }
  pd_buf = _newbuf;
  pd_max = _newmax;
}

STI::Types::TMeasurementSeq::TMeasurementSeq(const ::STI::Types::TMeasurementSeq& _s)
  : _CORBA_Unbounded_Sequence_Forward< STI::Types::TMeasurement > (_s.pd_max, 0, 0, 1)
{
  length(_s.pd_len);
  for (_CORBA_ULong _i=0; _i < pd_len; _i++) {
    pd_buf[_i] = _s.pd_buf[_i];
  }
}

void
STI::Types::TMeasurementSeq::operator<<= (cdrStream& _s)
{
  _CORBA_ULong _l;
  _l <<= _s;
  if (!_s.checkInputOverrun(1,_l)) {
    _CORBA_marshal_sequence_range_check_error(_s);
    // never reach here
  }
  length(_l);
  for( _CORBA_ULong _i = 0; _i < _l; _i++ )
    pd_buf[_i] <<= _s;
}

void
STI::Types::TMeasurementSeq::operator>>= (cdrStream& _s) const
{
  ::operator>>=(_CORBA_ULong(pd_len), _s);
  for( _CORBA_ULong _i = 0; _i < pd_len; _i++ )
    pd_buf[_i] >>= _s;
}

STI::Types::TMeasurementSeq&
STI::Types::TMeasurementSeq::operator=(const ::STI::Types::TMeasurementSeq& _s)
{
  length(_s.pd_len);
  for (unsigned long _i=0; _i < pd_len; _i++) {
    pd_buf[_i] = _s.pd_buf[_i];
  }
  return *this;
}

STI::Types::TMeasurement&
STI::Types::TMeasurementSeq::operator[](_CORBA_ULong _index)
{
  if (_index >= pd_len) _CORBA_bound_check_error();
  return pd_buf[_index];
}

const STI::Types::TMeasurement&
STI::Types::TMeasurementSeq::operator[](_CORBA_ULong _index) const
{
  if (_index >= pd_len) _CORBA_bound_check_error();
  return pd_buf[_index];
}

STI::Types::TMeasurement*
STI::Types::TMeasurementSeq::allocbuf(_CORBA_ULong _nelems)
{
  ::STI::Types::TMeasurement* _tmp = 0;
  if (_nelems) {
    _tmp = new ::STI::Types::TMeasurement[_nelems];
  }
  return _tmp;
}

void
STI::Types::TMeasurementSeq::freebuf(::STI::Types::TMeasurement* _b)
{
  if (_b) delete [] _b;
}

void
STI::Types::TMeasurementSeq::NP_freebuf()
{
  if (pd_buf) delete [] pd_buf;
}

STI::Types::TMeasurementSeq::~TMeasurementSeq()
{
  if (pd_rel && pd_buf) delete [] pd_buf;
  pd_buf = 0;
}

void
STI::Types::TMeasurementSeq::NP_copybuffer(_CORBA_ULong _newmax)
{
  // replace pd_data with a new buffer of size newmax.
  // Invariant:  pd_len <= newmax
  //
  ::STI::Types::TMeasurement* _newbuf = allocbuf(_newmax);
  if (!_newbuf) {
    _CORBA_new_operator_return_null();
    // never reach here
  }
  for (unsigned long _i=0; _i < pd_len; _i++) {
    _newbuf[_i] = pd_buf[_i];
  }
  if (pd_rel && pd_buf) {
    freebuf(pd_buf);
  }
  else {
    pd_rel = 1;
  }
  pd_buf = _newbuf;
  pd_max = _newmax;
}

STI::Types::TOverwrittenSeq::TOverwrittenSeq(const ::STI::Types::TOverwrittenSeq& _s)
  : _CORBA_Unbounded_Sequence_Forward< STI::Types::TOverwritten > (_s.pd_max, 0, 0, 1)
{
  length(_s.pd_len);
  for (_CORBA_ULong _i=0; _i < pd_len; _i++) {
    pd_buf[_i] = _s.pd_buf[_i];
  }
}

void
STI::Types::TOverwrittenSeq::operator<<= (cdrStream& _s)
{
  _CORBA_ULong _l;
  _l <<= _s;
  if (!_s.checkInputOverrun(1,_l)) {
    _CORBA_marshal_sequence_range_check_error(_s);
    // never reach here
  }
  length(_l);
  for( _CORBA_ULong _i = 0; _i < _l; _i++ )
    pd_buf[_i] <<= _s;
}

void
STI::Types::TOverwrittenSeq::operator>>= (cdrStream& _s) const
{
  ::operator>>=(_CORBA_ULong(pd_len), _s);
  for( _CORBA_ULong _i = 0; _i < pd_len; _i++ )
    pd_buf[_i] >>= _s;
}

STI::Types::TOverwrittenSeq&
STI::Types::TOverwrittenSeq::operator=(const ::STI::Types::TOverwrittenSeq& _s)
{
  length(_s.pd_len);
  for (unsigned long _i=0; _i < pd_len; _i++) {
    pd_buf[_i] = _s.pd_buf[_i];
  }
  return *this;
}

STI::Types::TOverwritten&
STI::Types::TOverwrittenSeq::operator[](_CORBA_ULong _index)
{
  if (_index >= pd_len) _CORBA_bound_check_error();
  return pd_buf[_index];
}

const STI::Types::TOverwritten&
STI::Types::TOverwrittenSeq::operator[](_CORBA_ULong _index) const
{
  if (_index >= pd_len) _CORBA_bound_check_error();
  return pd_buf[_index];
}

STI::Types::TOverwritten*
STI::Types::TOverwrittenSeq::allocbuf(_CORBA_ULong _nelems)
{
  ::STI::Types::TOverwritten* _tmp = 0;
  if (_nelems) {
    _tmp = new ::STI::Types::TOverwritten[_nelems];
  }
  return _tmp;
}

void
STI::Types::TOverwrittenSeq::freebuf(::STI::Types::TOverwritten* _b)
{
  if (_b) delete [] _b;
}

void
STI::Types::TOverwrittenSeq::NP_freebuf()
{
  if (pd_buf) delete [] pd_buf;
}

STI::Types::TOverwrittenSeq::~TOverwrittenSeq()
{
  if (pd_rel && pd_buf) delete [] pd_buf;
  pd_buf = 0;
}

void
STI::Types::TOverwrittenSeq::NP_copybuffer(_CORBA_ULong _newmax)
{
  // replace pd_data with a new buffer of size newmax.
  // Invariant:  pd_len <= newmax
  //
  ::STI::Types::TOverwritten* _newbuf = allocbuf(_newmax);
  if (!_newbuf) {
    _CORBA_new_operator_return_null();
    // never reach here
  }
  for (unsigned long _i=0; _i < pd_len; _i++) {
    _newbuf[_i] = pd_buf[_i];
  }
  if (pd_rel && pd_buf) {
    freebuf(pd_buf);
  }
  else {
    pd_rel = 1;
  }
  pd_buf = _newbuf;
  pd_max = _newmax;
}

STI::Types::TPartnerSeq::TPartnerSeq(const ::STI::Types::TPartnerSeq& _s)
  : _CORBA_Unbounded_Sequence_Forward< STI::Types::TPartner > (_s.pd_max, 0, 0, 1)
{
  length(_s.pd_len);
  for (_CORBA_ULong _i=0; _i < pd_len; _i++) {
    pd_buf[_i] = _s.pd_buf[_i];
  }
}

void
STI::Types::TPartnerSeq::operator<<= (cdrStream& _s)
{
  _CORBA_ULong _l;
  _l <<= _s;
  if (!_s.checkInputOverrun(1,_l)) {
    _CORBA_marshal_sequence_range_check_error(_s);
    // never reach here
  }
  length(_l);
  for( _CORBA_ULong _i = 0; _i < _l; _i++ )
    pd_buf[_i] <<= _s;
}

void
STI::Types::TPartnerSeq::operator>>= (cdrStream& _s) const
{
  ::operator>>=(_CORBA_ULong(pd_len), _s);
  for( _CORBA_ULong _i = 0; _i < pd_len; _i++ )
    pd_buf[_i] >>= _s;
}

STI::Types::TPartnerSeq&
STI::Types::TPartnerSeq::operator=(const ::STI::Types::TPartnerSeq& _s)
{
  length(_s.pd_len);
  for (unsigned long _i=0; _i < pd_len; _i++) {
    pd_buf[_i] = _s.pd_buf[_i];
  }
  return *this;
}

STI::Types::TPartner&
STI::Types::TPartnerSeq::operator[](_CORBA_ULong _index)
{
  if (_index >= pd_len) _CORBA_bound_check_error();
  return pd_buf[_index];
}

const STI::Types::TPartner&
STI::Types::TPartnerSeq::operator[](_CORBA_ULong _index) const
{
  if (_index >= pd_len) _CORBA_bound_check_error();
  return pd_buf[_index];
}

STI::Types::TPartner*
STI::Types::TPartnerSeq::allocbuf(_CORBA_ULong _nelems)
{
  ::STI::Types::TPartner* _tmp = 0;
  if (_nelems) {
    _tmp = new ::STI::Types::TPartner[_nelems];
  }
  return _tmp;
}

void
STI::Types::TPartnerSeq::freebuf(::STI::Types::TPartner* _b)
{
  if (_b) delete [] _b;
}

void
STI::Types::TPartnerSeq::NP_freebuf()
{
  if (pd_buf) delete [] pd_buf;
}

STI::Types::TPartnerSeq::~TPartnerSeq()
{
  if (pd_rel && pd_buf) delete [] pd_buf;
  pd_buf = 0;
}

void
STI::Types::TPartnerSeq::NP_copybuffer(_CORBA_ULong _newmax)
{
  // replace pd_data with a new buffer of size newmax.
  // Invariant:  pd_len <= newmax
  //
  ::STI::Types::TPartner* _newbuf = allocbuf(_newmax);
  if (!_newbuf) {
    _CORBA_new_operator_return_null();
    // never reach here
  }
  for (unsigned long _i=0; _i < pd_len; _i++) {
    _newbuf[_i] = pd_buf[_i];
  }
  if (pd_rel && pd_buf) {
    freebuf(pd_buf);
  }
  else {
    pd_rel = 1;
  }
  pd_buf = _newbuf;
  pd_max = _newmax;
}

STI::Types::TRowSeq::TRowSeq(const ::STI::Types::TRowSeq& _s)
  : _CORBA_Unbounded_Sequence_Forward< STI::Types::TRow > (_s.pd_max, 0, 0, 1)
{
  length(_s.pd_len);
  for (_CORBA_ULong _i=0; _i < pd_len; _i++) {
    pd_buf[_i] = _s.pd_buf[_i];
  }
}

void
STI::Types::TRowSeq::operator<<= (cdrStream& _s)
{
  _CORBA_ULong _l;
  _l <<= _s;
  if (!_s.checkInputOverrun(1,_l)) {
    _CORBA_marshal_sequence_range_check_error(_s);
    // never reach here
  }
  length(_l);
  for( _CORBA_ULong _i = 0; _i < _l; _i++ )
    pd_buf[_i] <<= _s;
}

void
STI::Types::TRowSeq::operator>>= (cdrStream& _s) const
{
  ::operator>>=(_CORBA_ULong(pd_len), _s);
  for( _CORBA_ULong _i = 0; _i < pd_len; _i++ )
    pd_buf[_i] >>= _s;
}

STI::Types::TRowSeq&
STI::Types::TRowSeq::operator=(const ::STI::Types::TRowSeq& _s)
{
  length(_s.pd_len);
  for (unsigned long _i=0; _i < pd_len; _i++) {
    pd_buf[_i] = _s.pd_buf[_i];
  }
  return *this;
}

STI::Types::TRow&
STI::Types::TRowSeq::operator[](_CORBA_ULong _index)
{
  if (_index >= pd_len) _CORBA_bound_check_error();
  return pd_buf[_index];
}

const STI::Types::TRow&
STI::Types::TRowSeq::operator[](_CORBA_ULong _index) const
{
  if (_index >= pd_len) _CORBA_bound_check_error();
  return pd_buf[_index];
}

STI::Types::TRow*
STI::Types::TRowSeq::allocbuf(_CORBA_ULong _nelems)
{
  ::STI::Types::TRow* _tmp = 0;
  if (_nelems) {
    _tmp = new ::STI::Types::TRow[_nelems];
  }
  return _tmp;
}

void
STI::Types::TRowSeq::freebuf(::STI::Types::TRow* _b)
{
  if (_b) delete [] _b;
}

void
STI::Types::TRowSeq::NP_freebuf()
{
  if (pd_buf) delete [] pd_buf;
}

STI::Types::TRowSeq::~TRowSeq()
{
  if (pd_rel && pd_buf) delete [] pd_buf;
  pd_buf = 0;
}

void
STI::Types::TRowSeq::NP_copybuffer(_CORBA_ULong _newmax)
{
  // replace pd_data with a new buffer of size newmax.
  // Invariant:  pd_len <= newmax
  //
  ::STI::Types::TRow* _newbuf = allocbuf(_newmax);
  if (!_newbuf) {
    _CORBA_new_operator_return_null();
    // never reach here
  }
  for (unsigned long _i=0; _i < pd_len; _i++) {
    _newbuf[_i] = pd_buf[_i];
  }
  if (pd_rel && pd_buf) {
    freebuf(pd_buf);
  }
  else {
    pd_rel = 1;
  }
  pd_buf = _newbuf;
  pd_max = _newmax;
}

STI::Types::TValMixedSeq::TValMixedSeq(const ::STI::Types::TValMixedSeq& _s)
  : _CORBA_Unbounded_Sequence_Forward< STI::Types::TValMixed > (_s.pd_max, 0, 0, 1)
{
  length(_s.pd_len);
  for (_CORBA_ULong _i=0; _i < pd_len; _i++) {
    pd_buf[_i] = _s.pd_buf[_i];
  }
}

void
STI::Types::TValMixedSeq::operator<<= (cdrStream& _s)
{
  _CORBA_ULong _l;
  _l <<= _s;
  if (!_s.checkInputOverrun(1,_l)) {
    _CORBA_marshal_sequence_range_check_error(_s);
    // never reach here
  }
  length(_l);
  for( _CORBA_ULong _i = 0; _i < _l; _i++ )
    pd_buf[_i] <<= _s;
}

void
STI::Types::TValMixedSeq::operator>>= (cdrStream& _s) const
{
  ::operator>>=(_CORBA_ULong(pd_len), _s);
  for( _CORBA_ULong _i = 0; _i < pd_len; _i++ )
    pd_buf[_i] >>= _s;
}

STI::Types::TValMixedSeq&
STI::Types::TValMixedSeq::operator=(const ::STI::Types::TValMixedSeq& _s)
{
  length(_s.pd_len);
  for (unsigned long _i=0; _i < pd_len; _i++) {
    pd_buf[_i] = _s.pd_buf[_i];
  }
  return *this;
}

STI::Types::TValMixed&
STI::Types::TValMixedSeq::operator[](_CORBA_ULong _index)
{
  if (_index >= pd_len) _CORBA_bound_check_error();
  return pd_buf[_index];
}

const STI::Types::TValMixed&
STI::Types::TValMixedSeq::operator[](_CORBA_ULong _index) const
{
  if (_index >= pd_len) _CORBA_bound_check_error();
  return pd_buf[_index];
}

STI::Types::TValMixed*
STI::Types::TValMixedSeq::allocbuf(_CORBA_ULong _nelems)
{
  ::STI::Types::TValMixed* _tmp = 0;
  if (_nelems) {
    _tmp = new ::STI::Types::TValMixed[_nelems];
  }
  return _tmp;
}

void
STI::Types::TValMixedSeq::freebuf(::STI::Types::TValMixed* _b)
{
  if (_b) delete [] _b;
}

void
STI::Types::TValMixedSeq::NP_freebuf()
{
  if (pd_buf) delete [] pd_buf;
}

STI::Types::TValMixedSeq::~TValMixedSeq()
{
  if (pd_rel && pd_buf) delete [] pd_buf;
  pd_buf = 0;
}

void
STI::Types::TValMixedSeq::NP_copybuffer(_CORBA_ULong _newmax)
{
  // replace pd_data with a new buffer of size newmax.
  // Invariant:  pd_len <= newmax
  //
  ::STI::Types::TValMixed* _newbuf = allocbuf(_newmax);
  if (!_newbuf) {
    _CORBA_new_operator_return_null();
    // never reach here
  }
  for (unsigned long _i=0; _i < pd_len; _i++) {
    _newbuf[_i] = pd_buf[_i];
  }
  if (pd_rel && pd_buf) {
    freebuf(pd_buf);
  }
  else {
    pd_rel = 1;
  }
  pd_buf = _newbuf;
  pd_max = _newmax;
}

STI::Types::TVariableSeq::TVariableSeq(const ::STI::Types::TVariableSeq& _s)
  : _CORBA_Unbounded_Sequence_Forward< STI::Types::TVariable > (_s.pd_max, 0, 0, 1)
{
  length(_s.pd_len);
  for (_CORBA_ULong _i=0; _i < pd_len; _i++) {
    pd_buf[_i] = _s.pd_buf[_i];
  }
}

void
STI::Types::TVariableSeq::operator<<= (cdrStream& _s)
{
  _CORBA_ULong _l;
  _l <<= _s;
  if (!_s.checkInputOverrun(1,_l)) {
    _CORBA_marshal_sequence_range_check_error(_s);
    // never reach here
  }
  length(_l);
  for( _CORBA_ULong _i = 0; _i < _l; _i++ )
    pd_buf[_i] <<= _s;
}

void
STI::Types::TVariableSeq::operator>>= (cdrStream& _s) const
{
  ::operator>>=(_CORBA_ULong(pd_len), _s);
  for( _CORBA_ULong _i = 0; _i < pd_len; _i++ )
    pd_buf[_i] >>= _s;
}

STI::Types::TVariableSeq&
STI::Types::TVariableSeq::operator=(const ::STI::Types::TVariableSeq& _s)
{
  length(_s.pd_len);
  for (unsigned long _i=0; _i < pd_len; _i++) {
    pd_buf[_i] = _s.pd_buf[_i];
  }
  return *this;
}

STI::Types::TVariable&
STI::Types::TVariableSeq::operator[](_CORBA_ULong _index)
{
  if (_index >= pd_len) _CORBA_bound_check_error();
  return pd_buf[_index];
}

const STI::Types::TVariable&
STI::Types::TVariableSeq::operator[](_CORBA_ULong _index) const
{
  if (_index >= pd_len) _CORBA_bound_check_error();
  return pd_buf[_index];
}

STI::Types::TVariable*
STI::Types::TVariableSeq::allocbuf(_CORBA_ULong _nelems)
{
  ::STI::Types::TVariable* _tmp = 0;
  if (_nelems) {
    _tmp = new ::STI::Types::TVariable[_nelems];
  }
  return _tmp;
}

void
STI::Types::TVariableSeq::freebuf(::STI::Types::TVariable* _b)
{
  if (_b) delete [] _b;
}

void
STI::Types::TVariableSeq::NP_freebuf()
{
  if (pd_buf) delete [] pd_buf;
}

STI::Types::TVariableSeq::~TVariableSeq()
{
  if (pd_rel && pd_buf) delete [] pd_buf;
  pd_buf = 0;
}

void
STI::Types::TVariableSeq::NP_copybuffer(_CORBA_ULong _newmax)
{
  // replace pd_data with a new buffer of size newmax.
  // Invariant:  pd_len <= newmax
  //
  ::STI::Types::TVariable* _newbuf = allocbuf(_newmax);
  if (!_newbuf) {
    _CORBA_new_operator_return_null();
    // never reach here
  }
  for (unsigned long _i=0; _i < pd_len; _i++) {
    _newbuf[_i] = pd_buf[_i];
  }
  if (pd_rel && pd_buf) {
    freebuf(pd_buf);
  }
  else {
    pd_rel = 1;
  }
  pd_buf = _newbuf;
  pd_max = _newmax;
}

STI::Types::TVarMixedSeq::TVarMixedSeq(const ::STI::Types::TVarMixedSeq& _s)
  : _CORBA_Unbounded_Sequence_Forward< STI::Types::TVarMixed > (_s.pd_max, 0, 0, 1)
{
  length(_s.pd_len);
  for (_CORBA_ULong _i=0; _i < pd_len; _i++) {
    pd_buf[_i] = _s.pd_buf[_i];
  }
}

void
STI::Types::TVarMixedSeq::operator<<= (cdrStream& _s)
{
  _CORBA_ULong _l;
  _l <<= _s;
  if (!_s.checkInputOverrun(1,_l)) {
    _CORBA_marshal_sequence_range_check_error(_s);
    // never reach here
  }
  length(_l);
  for( _CORBA_ULong _i = 0; _i < _l; _i++ )
    pd_buf[_i] <<= _s;
}

void
STI::Types::TVarMixedSeq::operator>>= (cdrStream& _s) const
{
  ::operator>>=(_CORBA_ULong(pd_len), _s);
  for( _CORBA_ULong _i = 0; _i < pd_len; _i++ )
    pd_buf[_i] >>= _s;
}

STI::Types::TVarMixedSeq&
STI::Types::TVarMixedSeq::operator=(const ::STI::Types::TVarMixedSeq& _s)
{
  length(_s.pd_len);
  for (unsigned long _i=0; _i < pd_len; _i++) {
    pd_buf[_i] = _s.pd_buf[_i];
  }
  return *this;
}

STI::Types::TVarMixed&
STI::Types::TVarMixedSeq::operator[](_CORBA_ULong _index)
{
  if (_index >= pd_len) _CORBA_bound_check_error();
  return pd_buf[_index];
}

const STI::Types::TVarMixed&
STI::Types::TVarMixedSeq::operator[](_CORBA_ULong _index) const
{
  if (_index >= pd_len) _CORBA_bound_check_error();
  return pd_buf[_index];
}

STI::Types::TVarMixed*
STI::Types::TVarMixedSeq::allocbuf(_CORBA_ULong _nelems)
{
  ::STI::Types::TVarMixed* _tmp = 0;
  if (_nelems) {
    _tmp = new ::STI::Types::TVarMixed[_nelems];
  }
  return _tmp;
}

void
STI::Types::TVarMixedSeq::freebuf(::STI::Types::TVarMixed* _b)
{
  if (_b) delete [] _b;
}

void
STI::Types::TVarMixedSeq::NP_freebuf()
{
  if (pd_buf) delete [] pd_buf;
}

STI::Types::TVarMixedSeq::~TVarMixedSeq()
{
  if (pd_rel && pd_buf) delete [] pd_buf;
  pd_buf = 0;
}

void
STI::Types::TVarMixedSeq::NP_copybuffer(_CORBA_ULong _newmax)
{
  // replace pd_data with a new buffer of size newmax.
  // Invariant:  pd_len <= newmax
  //
  ::STI::Types::TVarMixed* _newbuf = allocbuf(_newmax);
  if (!_newbuf) {
    _CORBA_new_operator_return_null();
    // never reach here
  }
  for (unsigned long _i=0; _i < pd_len; _i++) {
    _newbuf[_i] = pd_buf[_i];
  }
  if (pd_rel && pd_buf) {
    freebuf(pd_buf);
  }
  else {
    pd_rel = 1;
  }
  pd_buf = _newbuf;
  pd_max = _newmax;
}

STI::Types::TNetworkFile_ptr STI::Types::TNetworkFile_Helper::_nil() {
  return ::STI::Types::TNetworkFile::_nil();
}

::CORBA::Boolean STI::Types::TNetworkFile_Helper::is_nil(::STI::Types::TNetworkFile_ptr p) {
  return ::CORBA::is_nil(p);

}

void STI::Types::TNetworkFile_Helper::release(::STI::Types::TNetworkFile_ptr p) {
  ::CORBA::release(p);
}

void STI::Types::TNetworkFile_Helper::marshalObjRef(::STI::Types::TNetworkFile_ptr obj, cdrStream& s) {
  ::STI::Types::TNetworkFile::_marshalObjRef(obj, s);
}

STI::Types::TNetworkFile_ptr STI::Types::TNetworkFile_Helper::unmarshalObjRef(cdrStream& s) {
  return ::STI::Types::TNetworkFile::_unmarshalObjRef(s);
}

void STI::Types::TNetworkFile_Helper::duplicate(::STI::Types::TNetworkFile_ptr obj) {
  if( obj && !obj->_NP_is_nil() )  omni::duplicateObjRef(obj);
}

STI::Types::TNetworkFile_ptr
STI::Types::TNetworkFile::_duplicate(::STI::Types::TNetworkFile_ptr obj)
{
  if( obj && !obj->_NP_is_nil() )  omni::duplicateObjRef(obj);
  return obj;
}

STI::Types::TNetworkFile_ptr
STI::Types::TNetworkFile::_narrow(::CORBA::Object_ptr obj)
{
  if( !obj || obj->_NP_is_nil() || obj->_NP_is_pseudo() ) return _nil();
  _ptr_type e = (_ptr_type) obj->_PR_getobj()->_realNarrow(_PD_repoId);
  return e ? e : _nil();
}


STI::Types::TNetworkFile_ptr
STI::Types::TNetworkFile::_unchecked_narrow(::CORBA::Object_ptr obj)
{
  if( !obj || obj->_NP_is_nil() || obj->_NP_is_pseudo() ) return _nil();
  _ptr_type e = (_ptr_type) obj->_PR_getobj()->_uncheckedNarrow(_PD_repoId);
  return e ? e : _nil();
}

STI::Types::TNetworkFile_ptr
STI::Types::TNetworkFile::_nil()
{
#ifdef OMNI_UNLOADABLE_STUBS
  static _objref_TNetworkFile _the_nil_obj;
  return &_the_nil_obj;
#else
  static _objref_TNetworkFile* _the_nil_ptr = 0;
  if( !_the_nil_ptr ) {
    omni::nilRefLock().lock();
    if( !_the_nil_ptr ) {
      _the_nil_ptr = new _objref_TNetworkFile;
      registerNilCorbaObject(_the_nil_ptr);
    }
    omni::nilRefLock().unlock();
  }
  return _the_nil_ptr;
#endif
}

const char* STI::Types::TNetworkFile::_PD_repoId = "IDL:STI/Types/TNetworkFile:1.0";


STI::Types::_objref_TNetworkFile::~_objref_TNetworkFile() {
  
}


STI::Types::_objref_TNetworkFile::_objref_TNetworkFile(omniIOR* ior, omniIdentity* id) :
   omniObjRef(::STI::Types::TNetworkFile::_PD_repoId, ior, id, 1)
   
   
{
  _PR_setobj(this);
}

void*
STI::Types::_objref_TNetworkFile::_ptrToObjRef(const char* id)
{
  if( id == ::STI::Types::TNetworkFile::_PD_repoId )
    return (::STI::Types::TNetworkFile_ptr) this;
  
  if( id == ::CORBA::Object::_PD_repoId )
    return (::CORBA::Object_ptr) this;

  if( omni::strMatch(id, ::STI::Types::TNetworkFile::_PD_repoId) )
    return (::STI::Types::TNetworkFile_ptr) this;
  
  if( omni::strMatch(id, ::CORBA::Object::_PD_repoId) )
    return (::CORBA::Object_ptr) this;

  return 0;
}

// Proxy call descriptor class. Mangled signature:
//  _cboolean_i_clong_i_clong_o_cSTI_mTypes_mTOctetSeq
class _0RL_cd_168a21aee6a2b7c3_00000000
  : public omniCallDescriptor
{
public:
  inline _0RL_cd_168a21aee6a2b7c3_00000000(LocalCallFn lcfn,const char* op_,size_t oplen,_CORBA_Boolean upcall=0):
     omniCallDescriptor(lcfn, op_, oplen, 0, 0, 0, upcall)
  {
    
  }
  
  void marshalArguments(cdrStream&);
  void unmarshalArguments(cdrStream&);

  void unmarshalReturnedValues(cdrStream&);
  void marshalReturnedValues(cdrStream&);
  
  
  ::CORBA::Long arg_0;
  ::CORBA::Long arg_1;
  STI::Types::TOctetSeq_var arg_2;
  ::CORBA::Boolean result;
};

void _0RL_cd_168a21aee6a2b7c3_00000000::marshalArguments(cdrStream& _n)
{
  arg_0 >>= _n;
  arg_1 >>= _n;

}

void _0RL_cd_168a21aee6a2b7c3_00000000::unmarshalArguments(cdrStream& _n)
{
  (::CORBA::Long&)arg_0 <<= _n;
  (::CORBA::Long&)arg_1 <<= _n;

}

void _0RL_cd_168a21aee6a2b7c3_00000000::marshalReturnedValues(cdrStream& _n)
{
  _n.marshalBoolean(result);
  (const STI::Types::TOctetSeq&) arg_2 >>= _n;

}

void _0RL_cd_168a21aee6a2b7c3_00000000::unmarshalReturnedValues(cdrStream& _n)
{
  result = _n.unmarshalBoolean();
  arg_2 = new STI::Types::TOctetSeq;
  (STI::Types::TOctetSeq&)arg_2 <<= _n;

}

// Local call call-back function.
static void
_0RL_lcfn_168a21aee6a2b7c3_10000000(omniCallDescriptor* cd, omniServant* svnt)
{
  _0RL_cd_168a21aee6a2b7c3_00000000* tcd = (_0RL_cd_168a21aee6a2b7c3_00000000*)cd;
  STI::Types::_impl_TNetworkFile* impl = (STI::Types::_impl_TNetworkFile*) svnt->_ptrToInterface(STI::Types::TNetworkFile::_PD_repoId);
  tcd->result = impl->getBytes(tcd->arg_0, tcd->arg_1, tcd->arg_2.out());


}

::CORBA::Boolean STI::Types::_objref_TNetworkFile::getBytes(::CORBA::Long startByte, ::CORBA::Long numBytes, TOctetSeq_out bytes)
{
  _0RL_cd_168a21aee6a2b7c3_00000000 _call_desc(_0RL_lcfn_168a21aee6a2b7c3_10000000, "getBytes", 9);
  _call_desc.arg_0 = startByte;
  _call_desc.arg_1 = numBytes;

  _invoke(_call_desc);
  bytes = _call_desc.arg_2._retn();
  return _call_desc.result;


}
// Proxy call descriptor class. Mangled signature:
//  _cboolean
class _0RL_cd_168a21aee6a2b7c3_20000000
  : public omniCallDescriptor
{
public:
  inline _0RL_cd_168a21aee6a2b7c3_20000000(LocalCallFn lcfn,const char* op_,size_t oplen,_CORBA_Boolean upcall=0):
     omniCallDescriptor(lcfn, op_, oplen, 0, 0, 0, upcall)
  {
    
  }
  
  
  void unmarshalReturnedValues(cdrStream&);
  void marshalReturnedValues(cdrStream&);
  
  
  ::CORBA::Boolean result;
};

void _0RL_cd_168a21aee6a2b7c3_20000000::marshalReturnedValues(cdrStream& _n)
{
  _n.marshalBoolean(result);

}

void _0RL_cd_168a21aee6a2b7c3_20000000::unmarshalReturnedValues(cdrStream& _n)
{
  result = _n.unmarshalBoolean();

}

// Local call call-back function.
static void
_0RL_lcfn_168a21aee6a2b7c3_30000000(omniCallDescriptor* cd, omniServant* svnt)
{
  _0RL_cd_168a21aee6a2b7c3_20000000* tcd = (_0RL_cd_168a21aee6a2b7c3_20000000*)cd;
  STI::Types::_impl_TNetworkFile* impl = (STI::Types::_impl_TNetworkFile*) svnt->_ptrToInterface(STI::Types::TNetworkFile::_PD_repoId);
  tcd->result = impl->deleteRemoteFile();


}

::CORBA::Boolean STI::Types::_objref_TNetworkFile::deleteRemoteFile()
{
  _0RL_cd_168a21aee6a2b7c3_20000000 _call_desc(_0RL_lcfn_168a21aee6a2b7c3_30000000, "deleteRemoteFile", 17);


  _invoke(_call_desc);
  return _call_desc.result;


}
// Proxy call descriptor class. Mangled signature:
//  _cstring
class _0RL_cd_168a21aee6a2b7c3_40000000
  : public omniCallDescriptor
{
public:
  inline _0RL_cd_168a21aee6a2b7c3_40000000(LocalCallFn lcfn,const char* op_,size_t oplen,_CORBA_Boolean upcall=0):
     omniCallDescriptor(lcfn, op_, oplen, 0, 0, 0, upcall)
  {
    
  }
  
  
  void unmarshalReturnedValues(cdrStream&);
  void marshalReturnedValues(cdrStream&);
  
  
  ::CORBA::String_var result;
};

void _0RL_cd_168a21aee6a2b7c3_40000000::marshalReturnedValues(cdrStream& _n)
{
  _n.marshalString(result,0);

}

void _0RL_cd_168a21aee6a2b7c3_40000000::unmarshalReturnedValues(cdrStream& _n)
{
  result = _n.unmarshalString(0);

}

// Local call call-back function.
static void
_0RL_lcfn_168a21aee6a2b7c3_50000000(omniCallDescriptor* cd, omniServant* svnt)
{
  _0RL_cd_168a21aee6a2b7c3_40000000* tcd = (_0RL_cd_168a21aee6a2b7c3_40000000*)cd;
  STI::Types::_impl_TNetworkFile* impl = (STI::Types::_impl_TNetworkFile*) svnt->_ptrToInterface(STI::Types::TNetworkFile::_PD_repoId);
  tcd->result = impl->fileName();


}

char* STI::Types::_objref_TNetworkFile::fileName()
{
  _0RL_cd_168a21aee6a2b7c3_40000000 _call_desc(_0RL_lcfn_168a21aee6a2b7c3_50000000, "_get_fileName", 14);


  _invoke(_call_desc);
  return _call_desc.result._retn();


}
// Proxy call descriptor class. Mangled signature:
//  _clong
class _0RL_cd_168a21aee6a2b7c3_60000000
  : public omniCallDescriptor
{
public:
  inline _0RL_cd_168a21aee6a2b7c3_60000000(LocalCallFn lcfn,const char* op_,size_t oplen,_CORBA_Boolean upcall=0):
     omniCallDescriptor(lcfn, op_, oplen, 0, 0, 0, upcall)
  {
    
  }
  
  
  void unmarshalReturnedValues(cdrStream&);
  void marshalReturnedValues(cdrStream&);
  
  
  ::CORBA::Long result;
};

void _0RL_cd_168a21aee6a2b7c3_60000000::marshalReturnedValues(cdrStream& _n)
{
  result >>= _n;

}

void _0RL_cd_168a21aee6a2b7c3_60000000::unmarshalReturnedValues(cdrStream& _n)
{
  (::CORBA::Long&)result <<= _n;

}

// Local call call-back function.
static void
_0RL_lcfn_168a21aee6a2b7c3_70000000(omniCallDescriptor* cd, omniServant* svnt)
{
  _0RL_cd_168a21aee6a2b7c3_60000000* tcd = (_0RL_cd_168a21aee6a2b7c3_60000000*)cd;
  STI::Types::_impl_TNetworkFile* impl = (STI::Types::_impl_TNetworkFile*) svnt->_ptrToInterface(STI::Types::TNetworkFile::_PD_repoId);
  tcd->result = impl->length();


}

::CORBA::Long STI::Types::_objref_TNetworkFile::length()
{
  _0RL_cd_168a21aee6a2b7c3_60000000 _call_desc(_0RL_lcfn_168a21aee6a2b7c3_70000000, "_get_length", 12);


  _invoke(_call_desc);
  return _call_desc.result;


}
STI::Types::_pof_TNetworkFile::~_pof_TNetworkFile() {}


omniObjRef*
STI::Types::_pof_TNetworkFile::newObjRef(omniIOR* ior, omniIdentity* id)
{
  return new ::STI::Types::_objref_TNetworkFile(ior, id);
}


::CORBA::Boolean
STI::Types::_pof_TNetworkFile::is_a(const char* id) const
{
  if( omni::ptrStrMatch(id, ::STI::Types::TNetworkFile::_PD_repoId) )
    return 1;
  
  return 0;
}

const STI::Types::_pof_TNetworkFile _the_pof_STI_mTypes_mTNetworkFile;

STI::Types::_impl_TNetworkFile::~_impl_TNetworkFile() {}


::CORBA::Boolean
STI::Types::_impl_TNetworkFile::_dispatch(omniCallHandle& _handle)
{
  const char* op = _handle.operation_name();

  if( omni::strMatch(op, "getBytes") ) {

    _0RL_cd_168a21aee6a2b7c3_00000000 _call_desc(_0RL_lcfn_168a21aee6a2b7c3_10000000, "getBytes", 9, 1);
    
    _handle.upcall(this,_call_desc);
    return 1;
  }

  if( omni::strMatch(op, "deleteRemoteFile") ) {

    _0RL_cd_168a21aee6a2b7c3_20000000 _call_desc(_0RL_lcfn_168a21aee6a2b7c3_30000000, "deleteRemoteFile", 17, 1);
    
    _handle.upcall(this,_call_desc);
    return 1;
  }

  if( omni::strMatch(op, "_get_fileName") ) {

    _0RL_cd_168a21aee6a2b7c3_40000000 _call_desc(_0RL_lcfn_168a21aee6a2b7c3_50000000, "_get_fileName", 14, 1);
    
    _handle.upcall(this,_call_desc);
    return 1;
  }

  if( omni::strMatch(op, "_get_length") ) {

    _0RL_cd_168a21aee6a2b7c3_60000000 _call_desc(_0RL_lcfn_168a21aee6a2b7c3_70000000, "_get_length", 12, 1);
    
    _handle.upcall(this,_call_desc);
    return 1;
  }


  return 0;
}

void*
STI::Types::_impl_TNetworkFile::_ptrToInterface(const char* id)
{
  if( id == ::STI::Types::TNetworkFile::_PD_repoId )
    return (::STI::Types::_impl_TNetworkFile*) this;
  
  if( id == ::CORBA::Object::_PD_repoId )
    return (void*) 1;

  if( omni::strMatch(id, ::STI::Types::TNetworkFile::_PD_repoId) )
    return (::STI::Types::_impl_TNetworkFile*) this;
  
  if( omni::strMatch(id, ::CORBA::Object::_PD_repoId) )
    return (void*) 1;
  return 0;
}

const char*
STI::Types::_impl_TNetworkFile::_mostDerivedRepoId()
{
  return ::STI::Types::TNetworkFile::_PD_repoId;
}

void
STI::Types::TLogFile::operator>>= (cdrStream &_n) const
{
  TNetworkFile::_marshalObjRef(logFile,_n);
  startTime >>= _n;
  endTime >>= _n;

}

void
STI::Types::TLogFile::operator<<= (cdrStream &_n)
{
  logFile = TNetworkFile::_unmarshalObjRef(_n);
  (::CORBA::Long&)startTime <<= _n;
  (::CORBA::Long&)endTime <<= _n;

}

void
STI::Types::TDevice::operator>>= (cdrStream &_n) const
{
  _n.marshalString(deviceName,0);
  _n.marshalString(address,0);
  moduleNum >>= _n;
  _n.marshalString(deviceID,0);
  _n.marshalString(deviceContext,0);

}

void
STI::Types::TDevice::operator<<= (cdrStream &_n)
{
  deviceName = _n.unmarshalString(0);
  address = _n.unmarshalString(0);
  (::CORBA::UShort&)moduleNum <<= _n;
  deviceID = _n.unmarshalString(0);
  deviceContext = _n.unmarshalString(0);

}

void
STI::Types::TFile::operator>>= (cdrStream &_n) const
{
  _n.marshalString(fileName,0);
  _n.marshalString(fileServerAddress,0);
  _n.marshalString(fileServerDirectory,0);
  _n.marshalString(description,0);
  TNetworkFile::_marshalObjRef(networkFile,_n);

}

void
STI::Types::TFile::operator<<= (cdrStream &_n)
{
  fileName = _n.unmarshalString(0);
  fileServerAddress = _n.unmarshalString(0);
  fileServerDirectory = _n.unmarshalString(0);
  description = _n.unmarshalString(0);
  networkFile = TNetworkFile::_unmarshalObjRef(_n);

}

void
STI::Types::TPartner::operator>>= (cdrStream &_n) const
{
  _n.marshalString(partnerDeviceID,0);
  _n.marshalString(deviceName,0);
  _n.marshalString(ipAddress,0);
  moduleNum >>= _n;
  _n.marshalBoolean(isRequired);
  _n.marshalBoolean(isEventTarget);
  _n.marshalBoolean(isMutual);
  _n.marshalBoolean(isRegistered);

}

void
STI::Types::TPartner::operator<<= (cdrStream &_n)
{
  partnerDeviceID = _n.unmarshalString(0);
  deviceName = _n.unmarshalString(0);
  ipAddress = _n.unmarshalString(0);
  (::CORBA::UShort&)moduleNum <<= _n;
  isRequired = _n.unmarshalBoolean();
  isEventTarget = _n.unmarshalBoolean();
  isMutual = _n.unmarshalBoolean();
  isRegistered = _n.unmarshalBoolean();

}

void
STI::Types::TPicture::operator>>= (cdrStream &_n) const
{
  rowLength >>= _n;
  (const TshortSeq&) pixels >>= _n;

}

void
STI::Types::TPicture::operator<<= (cdrStream &_n)
{
  (::CORBA::UShort&)rowLength <<= _n;
  (TshortSeq&)pixels <<= _n;

}

void
STI::Types::TPosition::operator>>= (cdrStream &_n) const
{
  file >>= _n;
  line >>= _n;

}

void
STI::Types::TPosition::operator<<= (cdrStream &_n)
{
  (::CORBA::UShort&)file <<= _n;
  (::CORBA::ULong&)line <<= _n;

}

void
STI::Types::TDevicePosition::operator>>= (cdrStream &_n) const
{
  _n.marshalString(file,0);
  line >>= _n;

}

void
STI::Types::TDevicePosition::operator<<= (cdrStream &_n)
{
  file = _n.unmarshalString(0);
  (::CORBA::ULong&)line <<= _n;

}

void
STI::Types::TValMixed::operator>>= (cdrStream& _n) const
{
  _pd__d >>= _n;

  switch(_pd__d) {
    case ValueNumber:
      _pd_number >>= _n;
      break;
    case ValueString:
      _n.marshalString(_pd_stringVal,0);
      break;
    case ValueVector:
      (const TValMixedSeq&) _pd_vector >>= _n;
      break;
    case ValueNone:
      _n.marshalBoolean(_pd_emptyValue);
      break;
    default: break;

  
  }


}

void
STI::Types::TValMixed::operator<<= (cdrStream& _n)
{
  (TValue&)_pd__d <<= _n;

  switch(_pd__d) {
    case ValueNumber:
      _pd__default = 0;
      (::CORBA::Double&)_pd_number <<= _n;
      break;
    case ValueString:
      _pd__default = 0;
      _pd_stringVal = _n.unmarshalString(0);
      break;
    case ValueVector:
      _pd__default = 0;
      (TValMixedSeq&)_pd_vector <<= _n;
      break;
    case ValueNone:
      _pd__default = 0;
      _pd_emptyValue = _n.unmarshalBoolean();
      break;

  }
  _pd__initialised = 1;
}

void
STI::Types::TDataMixed::operator>>= (cdrStream& _n) const
{
  _pd__d >>= _n;

  switch(_pd__d) {
    case DataBoolean:
      _n.marshalBoolean(_pd_booleanVal);
      break;
    case DataOctet:
      _n.marshalOctet(_pd_octetVal);
      break;
    case DataLong:
      _pd_longVal >>= _n;
      break;
    case DataDouble:
      _pd_doubleVal >>= _n;
      break;
    case DataString:
      _n.marshalString(_pd_stringVal,0);
      break;
    case DataPicture:
      (const TPicture&) _pd_picture >>= _n;
      break;
    case DataVector:
      (const TDataMixedSeq&) _pd_vector >>= _n;
      break;
    case DataFile:
      (const TFile&) _pd_file >>= _n;
      break;
    case DataNone:
      _n.marshalBoolean(_pd_outVal);
      break;
    default: break;

  
  }


}

void
STI::Types::TDataMixed::operator<<= (cdrStream& _n)
{
  (TData&)_pd__d <<= _n;

  switch(_pd__d) {
    case DataBoolean:
      _pd__default = 0;
      _pd_booleanVal = _n.unmarshalBoolean();
      break;
    case DataOctet:
      _pd__default = 0;
      _pd_octetVal = _n.unmarshalOctet();
      break;
    case DataLong:
      _pd__default = 0;
      (::CORBA::Long&)_pd_longVal <<= _n;
      break;
    case DataDouble:
      _pd__default = 0;
      (::CORBA::Double&)_pd_doubleVal <<= _n;
      break;
    case DataString:
      _pd__default = 0;
      _pd_stringVal = _n.unmarshalString(0);
      break;
    case DataPicture:
      _pd__default = 0;
      (TPicture&)_pd_picture <<= _n;
      break;
    case DataVector:
      _pd__default = 0;
      (TDataMixedSeq&)_pd_vector <<= _n;
      break;
    case DataFile:
      _pd__default = 0;
      (TFile&)_pd_file <<= _n;
      break;
    case DataNone:
      _pd__default = 0;
      _pd_outVal = _n.unmarshalBoolean();
      break;

  }
  _pd__initialised = 1;
}

void
STI::Types::TVarMixed::operator>>= (cdrStream& _n) const
{
  _pd__d >>= _n;

  switch(_pd__d) {
    case TypeNumber:
      _pd_number >>= _n;
      break;
    case TypeString:
      _n.marshalString(_pd_stringVal,0);
      break;
    case TypeChannel:
      _pd_channel >>= _n;
      break;
    case TypeList:
      (const TVarMixedSeq&) _pd_list >>= _n;
      break;
    case TypeObject:
      _n.marshalString(_pd_objectVal,0);
      break;
    default: break;

  
  }


}

void
STI::Types::TVarMixed::operator<<= (cdrStream& _n)
{
  (TType&)_pd__d <<= _n;

  switch(_pd__d) {
    case TypeNumber:
      _pd__default = 0;
      (::CORBA::Double&)_pd_number <<= _n;
      break;
    case TypeString:
      _pd__default = 0;
      _pd_stringVal = _n.unmarshalString(0);
      break;
    case TypeChannel:
      _pd__default = 0;
      (::CORBA::UShort&)_pd_channel <<= _n;
      break;
    case TypeList:
      _pd__default = 0;
      (TVarMixedSeq&)_pd_list <<= _n;
      break;
    case TypeObject:
      _pd__default = 0;
      _pd_objectVal = _n.unmarshalString(0);
      break;

  }
  _pd__initialised = 1;
}

void
STI::Types::TAttribute::operator>>= (cdrStream &_n) const
{
  _n.marshalString(key,0);
  _n.marshalString(value,0);
  (const TStringSeq&) values >>= _n;

}

void
STI::Types::TAttribute::operator<<= (cdrStream &_n)
{
  key = _n.unmarshalString(0);
  value = _n.unmarshalString(0);
  (TStringSeq&)values <<= _n;

}

void
STI::Types::TChannel::operator>>= (cdrStream &_n) const
{
  (const TDevice&) device >>= _n;
  channel >>= _n;
  type >>= _n;
  inputType >>= _n;
  outputType >>= _n;

}

void
STI::Types::TChannel::operator<<= (cdrStream &_n)
{
  (TDevice&)device <<= _n;
  (::CORBA::UShort&)channel <<= _n;
  (TChannelType&)type <<= _n;
  (TData&)inputType <<= _n;
  (TValue&)outputType <<= _n;

}

void
STI::Types::TDeviceChannel::operator>>= (cdrStream &_n) const
{
  channel >>= _n;
  type >>= _n;
  inputType >>= _n;
  outputType >>= _n;

}

void
STI::Types::TDeviceChannel::operator<<= (cdrStream &_n)
{
  (::CORBA::UShort&)channel <<= _n;
  (TChannelType&)type <<= _n;
  (TData&)inputType <<= _n;
  (TValue&)outputType <<= _n;

}

void
STI::Types::TDeviceEvent::operator>>= (cdrStream &_n) const
{
  channel >>= _n;
  time >>= _n;
  (const TValMixed&) value >>= _n;
  (const TDevicePosition&) pos >>= _n;
  eventNum >>= _n;
  _n.marshalBoolean(isMeasurementEvent);
  _n.marshalString(description,0);

}

void
STI::Types::TDeviceEvent::operator<<= (cdrStream &_n)
{
  (::CORBA::UShort&)channel <<= _n;
  (::CORBA::Double&)time <<= _n;
  (TValMixed&)value <<= _n;
  (TDevicePosition&)pos <<= _n;
  (::CORBA::ULong&)eventNum <<= _n;
  isMeasurementEvent = _n.unmarshalBoolean();
  description = _n.unmarshalString(0);

}

void
STI::Types::TEvent::operator>>= (cdrStream &_n) const
{
  channel >>= _n;
  time >>= _n;
  (const TValMixed&) value >>= _n;
  (const TPosition&) pos >>= _n;
  _n.marshalBoolean(isMeasurementEvent);
  _n.marshalString(description,0);

}

void
STI::Types::TEvent::operator<<= (cdrStream &_n)
{
  (::CORBA::UShort&)channel <<= _n;
  (::CORBA::Double&)time <<= _n;
  (TValMixed&)value <<= _n;
  (TPosition&)pos <<= _n;
  isMeasurementEvent = _n.unmarshalBoolean();
  description = _n.unmarshalString(0);

}

void
STI::Types::TExpRunInfo::operator>>= (cdrStream &_n) const
{
  _n.marshalString(filename,0);
  _n.marshalString(description,0);
  _n.marshalString(serverBaseDirectory,0);
  _n.marshalBoolean(isSequenceMember);
  _n.marshalString(sequenceRelativePath,0);

}

void
STI::Types::TExpRunInfo::operator<<= (cdrStream &_n)
{
  filename = _n.unmarshalString(0);
  description = _n.unmarshalString(0);
  serverBaseDirectory = _n.unmarshalString(0);
  isSequenceMember = _n.unmarshalBoolean();
  sequenceRelativePath = _n.unmarshalString(0);

}

void
STI::Types::TExpSequenceInfo::operator>>= (cdrStream &_n) const
{
  _n.marshalString(filename,0);
  _n.marshalString(sequenceDescription,0);
  _n.marshalString(serverBaseDirectory,0);
  _n.marshalString(trialFilenameBase,0);

}

void
STI::Types::TExpSequenceInfo::operator<<= (cdrStream &_n)
{
  filename = _n.unmarshalString(0);
  sequenceDescription = _n.unmarshalString(0);
  serverBaseDirectory = _n.unmarshalString(0);
  trialFilenameBase = _n.unmarshalString(0);

}

void
STI::Types::TLabeledData::operator>>= (cdrStream &_n) const
{
  _n.marshalString(label,0);
  (const TDataMixed&) data >>= _n;

}

void
STI::Types::TLabeledData::operator<<= (cdrStream &_n)
{
  label = _n.unmarshalString(0);
  (TDataMixed&)data <<= _n;

}

void
STI::Types::TMeasurement::operator>>= (cdrStream &_n) const
{
  channel >>= _n;
  time >>= _n;
  (const TDataMixed&) data >>= _n;
  _n.marshalString(description,0);

}

void
STI::Types::TMeasurement::operator<<= (cdrStream &_n)
{
  (::CORBA::UShort&)channel <<= _n;
  (::CORBA::Double&)time <<= _n;
  (TDataMixed&)data <<= _n;
  description = _n.unmarshalString(0);

}

void
STI::Types::TOverwritten::operator>>= (cdrStream &_n) const
{
  _n.marshalString(name,0);
  _n.marshalString(value,0);

}

void
STI::Types::TOverwritten::operator<<= (cdrStream &_n)
{
  name = _n.unmarshalString(0);
  value = _n.unmarshalString(0);

}

void
STI::Types::TRow::operator>>= (cdrStream &_n) const
{
  row >>= _n;
  (const TStringSeq&) val >>= _n;
  _n.marshalBoolean(done);

}

void
STI::Types::TRow::operator<<= (cdrStream &_n)
{
  (::CORBA::ULong&)row <<= _n;
  (TStringSeq&)val <<= _n;
  done = _n.unmarshalBoolean();

}

void
STI::Types::TStatus::operator>>= (cdrStream &_n) const
{
  level >>= _n;
  curTime >>= _n;
  curEvent >>= _n;
  curCycle >>= _n;

}

void
STI::Types::TStatus::operator<<= (cdrStream &_n)
{
  (TStatusLevel&)level <<= _n;
  (::CORBA::Double&)curTime <<= _n;
  (::CORBA::ULong&)curEvent <<= _n;
  (::CORBA::UShort&)curCycle <<= _n;

}

void
STI::Types::TVariable::operator>>= (cdrStream &_n) const
{
  _n.marshalString(name,0);
  (const TVarMixed&) value >>= _n;
  (const TPosition&) pos >>= _n;

}

void
STI::Types::TVariable::operator<<= (cdrStream &_n)
{
  name = _n.unmarshalString(0);
  (TVarMixed&)value <<= _n;
  (TPosition&)pos <<= _n;

}

POA_STI::Types::TNetworkFile::~TNetworkFile() {}

