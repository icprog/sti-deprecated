// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef __orbTypes_hh__
#define __orbTypes_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_orbTypes
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_orbTypes
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_orbTypes
#endif






#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_MODULE STI

_CORBA_MODULE_BEG

  _CORBA_MODULE Types

  _CORBA_MODULE_BEG

    struct TAttribute;

    struct TChannel;

    class TDataMixed;

    struct TDevice;

    struct TDeviceChannel;

    struct TDeviceEvent;

    struct TEvent;

    struct TFile;

    struct TMeasurement;

    struct TOverwritten;

    struct TPartner;

    struct TPicture;

    struct TPosition;

    struct TRow;

    struct TVariable;

    class TValMixed;

    class TVarMixed;

    class TAttributeSeq_var;

    class TAttributeSeq : public _CORBA_Unbounded_Sequence_Forward< TAttribute >  {
    public:
      typedef TAttributeSeq_var _var_type;

      inline TAttributeSeq() {}
      TAttributeSeq(const TAttributeSeq& _s);
      TAttributeSeq& operator=(const TAttributeSeq& _s);

      inline TAttributeSeq(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_Forward< TAttribute > (_max) {}
      inline TAttributeSeq(_CORBA_ULong _max, _CORBA_ULong _len, TAttribute* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_Forward< TAttribute > (_max, _len, _val, _rel) {}

    

      virtual ~TAttributeSeq();

      TAttribute& operator[] (_CORBA_ULong _index);
      const TAttribute& operator[] (_CORBA_ULong _index) const;
      static TAttribute* allocbuf(_CORBA_ULong _nelems);
      static void freebuf(TAttribute* _b);

      void operator>>= (cdrStream &_s) const;
      void operator<<= (cdrStream &_s);

    protected:
      void NP_copybuffer(_CORBA_ULong _newmax);
      void NP_freebuf();
    };

    class TAttributeSeq_out;

    class TAttributeSeq_var {
    public:
      inline TAttributeSeq_var() : _pd_seq(0) {}
      inline TAttributeSeq_var(TAttributeSeq* _s) : _pd_seq(_s) {}
      inline TAttributeSeq_var(const TAttributeSeq_var& _s) {
        if( _s._pd_seq )  _pd_seq = new TAttributeSeq(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~TAttributeSeq_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline TAttributeSeq_var& operator = (TAttributeSeq* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline TAttributeSeq_var& operator = (const TAttributeSeq_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new TAttributeSeq;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline TAttribute& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline TAttributeSeq* operator -> () { return _pd_seq; }
      inline const TAttributeSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator TAttributeSeq& () const { return *_pd_seq; }
#else
      inline operator const TAttributeSeq& () const { return *_pd_seq; }
      inline operator TAttributeSeq& () { return *_pd_seq; }
#endif
        
      inline const TAttributeSeq& in() const { return *_pd_seq; }
      inline TAttributeSeq&       inout()    { return *_pd_seq; }
      inline TAttributeSeq*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline TAttributeSeq* _retn() { TAttributeSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class TAttributeSeq_out;
      
    private:
      TAttributeSeq* _pd_seq;
    };

    class TAttributeSeq_out {
    public:
      inline TAttributeSeq_out(TAttributeSeq*& _s) : _data(_s) { _data = 0; }
      inline TAttributeSeq_out(TAttributeSeq_var& _s)
        : _data(_s._pd_seq) { _s = (TAttributeSeq*) 0; }
      inline TAttributeSeq_out(const TAttributeSeq_out& _s) : _data(_s._data) {}
      inline TAttributeSeq_out& operator = (const TAttributeSeq_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline TAttributeSeq_out& operator = (TAttributeSeq* _s) {
        _data = _s;
        return *this;
      }
      inline operator TAttributeSeq*&()  { return _data; }
      inline TAttributeSeq*& ptr()       { return _data; }
      inline TAttributeSeq* operator->() { return _data; }

      inline TAttribute& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      TAttributeSeq*& _data;

    private:
      TAttributeSeq_out();
      TAttributeSeq_out& operator=(const TAttributeSeq_var&);
    };

    class TChannelSeq_var;

    class TChannelSeq : public _CORBA_Unbounded_Sequence_Forward< TChannel >  {
    public:
      typedef TChannelSeq_var _var_type;

      inline TChannelSeq() {}
      TChannelSeq(const TChannelSeq& _s);
      TChannelSeq& operator=(const TChannelSeq& _s);

      inline TChannelSeq(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_Forward< TChannel > (_max) {}
      inline TChannelSeq(_CORBA_ULong _max, _CORBA_ULong _len, TChannel* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_Forward< TChannel > (_max, _len, _val, _rel) {}

    

      virtual ~TChannelSeq();

      TChannel& operator[] (_CORBA_ULong _index);
      const TChannel& operator[] (_CORBA_ULong _index) const;
      static TChannel* allocbuf(_CORBA_ULong _nelems);
      static void freebuf(TChannel* _b);

      void operator>>= (cdrStream &_s) const;
      void operator<<= (cdrStream &_s);

    protected:
      void NP_copybuffer(_CORBA_ULong _newmax);
      void NP_freebuf();
    };

    class TChannelSeq_out;

    class TChannelSeq_var {
    public:
      inline TChannelSeq_var() : _pd_seq(0) {}
      inline TChannelSeq_var(TChannelSeq* _s) : _pd_seq(_s) {}
      inline TChannelSeq_var(const TChannelSeq_var& _s) {
        if( _s._pd_seq )  _pd_seq = new TChannelSeq(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~TChannelSeq_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline TChannelSeq_var& operator = (TChannelSeq* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline TChannelSeq_var& operator = (const TChannelSeq_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new TChannelSeq;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline TChannel& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline TChannelSeq* operator -> () { return _pd_seq; }
      inline const TChannelSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator TChannelSeq& () const { return *_pd_seq; }
#else
      inline operator const TChannelSeq& () const { return *_pd_seq; }
      inline operator TChannelSeq& () { return *_pd_seq; }
#endif
        
      inline const TChannelSeq& in() const { return *_pd_seq; }
      inline TChannelSeq&       inout()    { return *_pd_seq; }
      inline TChannelSeq*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline TChannelSeq* _retn() { TChannelSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class TChannelSeq_out;
      
    private:
      TChannelSeq* _pd_seq;
    };

    class TChannelSeq_out {
    public:
      inline TChannelSeq_out(TChannelSeq*& _s) : _data(_s) { _data = 0; }
      inline TChannelSeq_out(TChannelSeq_var& _s)
        : _data(_s._pd_seq) { _s = (TChannelSeq*) 0; }
      inline TChannelSeq_out(const TChannelSeq_out& _s) : _data(_s._data) {}
      inline TChannelSeq_out& operator = (const TChannelSeq_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline TChannelSeq_out& operator = (TChannelSeq* _s) {
        _data = _s;
        return *this;
      }
      inline operator TChannelSeq*&()  { return _data; }
      inline TChannelSeq*& ptr()       { return _data; }
      inline TChannelSeq* operator->() { return _data; }

      inline TChannel& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      TChannelSeq*& _data;

    private:
      TChannelSeq_out();
      TChannelSeq_out& operator=(const TChannelSeq_var&);
    };

    class TDataMixedSeq_var;

    class TDataMixedSeq : public _CORBA_Unbounded_Sequence_Forward< TDataMixed >  {
    public:
      typedef TDataMixedSeq_var _var_type;

      inline TDataMixedSeq() {}
      TDataMixedSeq(const TDataMixedSeq& _s);
      TDataMixedSeq& operator=(const TDataMixedSeq& _s);

      inline TDataMixedSeq(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_Forward< TDataMixed > (_max) {}
      inline TDataMixedSeq(_CORBA_ULong _max, _CORBA_ULong _len, TDataMixed* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_Forward< TDataMixed > (_max, _len, _val, _rel) {}

    

      virtual ~TDataMixedSeq();

      TDataMixed& operator[] (_CORBA_ULong _index);
      const TDataMixed& operator[] (_CORBA_ULong _index) const;
      static TDataMixed* allocbuf(_CORBA_ULong _nelems);
      static void freebuf(TDataMixed* _b);

      void operator>>= (cdrStream &_s) const;
      void operator<<= (cdrStream &_s);

    protected:
      void NP_copybuffer(_CORBA_ULong _newmax);
      void NP_freebuf();
    };

    class TDataMixedSeq_out;

    class TDataMixedSeq_var {
    public:
      inline TDataMixedSeq_var() : _pd_seq(0) {}
      inline TDataMixedSeq_var(TDataMixedSeq* _s) : _pd_seq(_s) {}
      inline TDataMixedSeq_var(const TDataMixedSeq_var& _s) {
        if( _s._pd_seq )  _pd_seq = new TDataMixedSeq(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~TDataMixedSeq_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline TDataMixedSeq_var& operator = (TDataMixedSeq* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline TDataMixedSeq_var& operator = (const TDataMixedSeq_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new TDataMixedSeq;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline TDataMixed& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline TDataMixedSeq* operator -> () { return _pd_seq; }
      inline const TDataMixedSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator TDataMixedSeq& () const { return *_pd_seq; }
#else
      inline operator const TDataMixedSeq& () const { return *_pd_seq; }
      inline operator TDataMixedSeq& () { return *_pd_seq; }
#endif
        
      inline const TDataMixedSeq& in() const { return *_pd_seq; }
      inline TDataMixedSeq&       inout()    { return *_pd_seq; }
      inline TDataMixedSeq*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline TDataMixedSeq* _retn() { TDataMixedSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class TDataMixedSeq_out;
      
    private:
      TDataMixedSeq* _pd_seq;
    };

    class TDataMixedSeq_out {
    public:
      inline TDataMixedSeq_out(TDataMixedSeq*& _s) : _data(_s) { _data = 0; }
      inline TDataMixedSeq_out(TDataMixedSeq_var& _s)
        : _data(_s._pd_seq) { _s = (TDataMixedSeq*) 0; }
      inline TDataMixedSeq_out(const TDataMixedSeq_out& _s) : _data(_s._data) {}
      inline TDataMixedSeq_out& operator = (const TDataMixedSeq_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline TDataMixedSeq_out& operator = (TDataMixedSeq* _s) {
        _data = _s;
        return *this;
      }
      inline operator TDataMixedSeq*&()  { return _data; }
      inline TDataMixedSeq*& ptr()       { return _data; }
      inline TDataMixedSeq* operator->() { return _data; }

      inline TDataMixed& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      TDataMixedSeq*& _data;

    private:
      TDataMixedSeq_out();
      TDataMixedSeq_out& operator=(const TDataMixedSeq_var&);
    };

    class TDeviceSeq_var;

    class TDeviceSeq : public _CORBA_Unbounded_Sequence_Forward< TDevice >  {
    public:
      typedef TDeviceSeq_var _var_type;

      inline TDeviceSeq() {}
      TDeviceSeq(const TDeviceSeq& _s);
      TDeviceSeq& operator=(const TDeviceSeq& _s);

      inline TDeviceSeq(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_Forward< TDevice > (_max) {}
      inline TDeviceSeq(_CORBA_ULong _max, _CORBA_ULong _len, TDevice* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_Forward< TDevice > (_max, _len, _val, _rel) {}

    

      virtual ~TDeviceSeq();

      TDevice& operator[] (_CORBA_ULong _index);
      const TDevice& operator[] (_CORBA_ULong _index) const;
      static TDevice* allocbuf(_CORBA_ULong _nelems);
      static void freebuf(TDevice* _b);

      void operator>>= (cdrStream &_s) const;
      void operator<<= (cdrStream &_s);

    protected:
      void NP_copybuffer(_CORBA_ULong _newmax);
      void NP_freebuf();
    };

    class TDeviceSeq_out;

    class TDeviceSeq_var {
    public:
      inline TDeviceSeq_var() : _pd_seq(0) {}
      inline TDeviceSeq_var(TDeviceSeq* _s) : _pd_seq(_s) {}
      inline TDeviceSeq_var(const TDeviceSeq_var& _s) {
        if( _s._pd_seq )  _pd_seq = new TDeviceSeq(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~TDeviceSeq_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline TDeviceSeq_var& operator = (TDeviceSeq* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline TDeviceSeq_var& operator = (const TDeviceSeq_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new TDeviceSeq;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline TDevice& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline TDeviceSeq* operator -> () { return _pd_seq; }
      inline const TDeviceSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator TDeviceSeq& () const { return *_pd_seq; }
#else
      inline operator const TDeviceSeq& () const { return *_pd_seq; }
      inline operator TDeviceSeq& () { return *_pd_seq; }
#endif
        
      inline const TDeviceSeq& in() const { return *_pd_seq; }
      inline TDeviceSeq&       inout()    { return *_pd_seq; }
      inline TDeviceSeq*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline TDeviceSeq* _retn() { TDeviceSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class TDeviceSeq_out;
      
    private:
      TDeviceSeq* _pd_seq;
    };

    class TDeviceSeq_out {
    public:
      inline TDeviceSeq_out(TDeviceSeq*& _s) : _data(_s) { _data = 0; }
      inline TDeviceSeq_out(TDeviceSeq_var& _s)
        : _data(_s._pd_seq) { _s = (TDeviceSeq*) 0; }
      inline TDeviceSeq_out(const TDeviceSeq_out& _s) : _data(_s._data) {}
      inline TDeviceSeq_out& operator = (const TDeviceSeq_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline TDeviceSeq_out& operator = (TDeviceSeq* _s) {
        _data = _s;
        return *this;
      }
      inline operator TDeviceSeq*&()  { return _data; }
      inline TDeviceSeq*& ptr()       { return _data; }
      inline TDeviceSeq* operator->() { return _data; }

      inline TDevice& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      TDeviceSeq*& _data;

    private:
      TDeviceSeq_out();
      TDeviceSeq_out& operator=(const TDeviceSeq_var&);
    };

    class TDeviceChannelSeq_var;

    class TDeviceChannelSeq : public _CORBA_Unbounded_Sequence_Forward< TDeviceChannel >  {
    public:
      typedef TDeviceChannelSeq_var _var_type;

      inline TDeviceChannelSeq() {}
      TDeviceChannelSeq(const TDeviceChannelSeq& _s);
      TDeviceChannelSeq& operator=(const TDeviceChannelSeq& _s);

      inline TDeviceChannelSeq(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_Forward< TDeviceChannel > (_max) {}
      inline TDeviceChannelSeq(_CORBA_ULong _max, _CORBA_ULong _len, TDeviceChannel* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_Forward< TDeviceChannel > (_max, _len, _val, _rel) {}

    

      virtual ~TDeviceChannelSeq();

      TDeviceChannel& operator[] (_CORBA_ULong _index);
      const TDeviceChannel& operator[] (_CORBA_ULong _index) const;
      static TDeviceChannel* allocbuf(_CORBA_ULong _nelems);
      static void freebuf(TDeviceChannel* _b);

      void operator>>= (cdrStream &_s) const;
      void operator<<= (cdrStream &_s);

    protected:
      void NP_copybuffer(_CORBA_ULong _newmax);
      void NP_freebuf();
    };

    class TDeviceChannelSeq_out;

    class TDeviceChannelSeq_var {
    public:
      inline TDeviceChannelSeq_var() : _pd_seq(0) {}
      inline TDeviceChannelSeq_var(TDeviceChannelSeq* _s) : _pd_seq(_s) {}
      inline TDeviceChannelSeq_var(const TDeviceChannelSeq_var& _s) {
        if( _s._pd_seq )  _pd_seq = new TDeviceChannelSeq(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~TDeviceChannelSeq_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline TDeviceChannelSeq_var& operator = (TDeviceChannelSeq* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline TDeviceChannelSeq_var& operator = (const TDeviceChannelSeq_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new TDeviceChannelSeq;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline TDeviceChannel& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline TDeviceChannelSeq* operator -> () { return _pd_seq; }
      inline const TDeviceChannelSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator TDeviceChannelSeq& () const { return *_pd_seq; }
#else
      inline operator const TDeviceChannelSeq& () const { return *_pd_seq; }
      inline operator TDeviceChannelSeq& () { return *_pd_seq; }
#endif
        
      inline const TDeviceChannelSeq& in() const { return *_pd_seq; }
      inline TDeviceChannelSeq&       inout()    { return *_pd_seq; }
      inline TDeviceChannelSeq*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline TDeviceChannelSeq* _retn() { TDeviceChannelSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class TDeviceChannelSeq_out;
      
    private:
      TDeviceChannelSeq* _pd_seq;
    };

    class TDeviceChannelSeq_out {
    public:
      inline TDeviceChannelSeq_out(TDeviceChannelSeq*& _s) : _data(_s) { _data = 0; }
      inline TDeviceChannelSeq_out(TDeviceChannelSeq_var& _s)
        : _data(_s._pd_seq) { _s = (TDeviceChannelSeq*) 0; }
      inline TDeviceChannelSeq_out(const TDeviceChannelSeq_out& _s) : _data(_s._data) {}
      inline TDeviceChannelSeq_out& operator = (const TDeviceChannelSeq_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline TDeviceChannelSeq_out& operator = (TDeviceChannelSeq* _s) {
        _data = _s;
        return *this;
      }
      inline operator TDeviceChannelSeq*&()  { return _data; }
      inline TDeviceChannelSeq*& ptr()       { return _data; }
      inline TDeviceChannelSeq* operator->() { return _data; }

      inline TDeviceChannel& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      TDeviceChannelSeq*& _data;

    private:
      TDeviceChannelSeq_out();
      TDeviceChannelSeq_out& operator=(const TDeviceChannelSeq_var&);
    };

    class TDeviceEventSeq_var;

    class TDeviceEventSeq : public _CORBA_Unbounded_Sequence_Forward< TDeviceEvent >  {
    public:
      typedef TDeviceEventSeq_var _var_type;

      inline TDeviceEventSeq() {}
      TDeviceEventSeq(const TDeviceEventSeq& _s);
      TDeviceEventSeq& operator=(const TDeviceEventSeq& _s);

      inline TDeviceEventSeq(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_Forward< TDeviceEvent > (_max) {}
      inline TDeviceEventSeq(_CORBA_ULong _max, _CORBA_ULong _len, TDeviceEvent* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_Forward< TDeviceEvent > (_max, _len, _val, _rel) {}

    

      virtual ~TDeviceEventSeq();

      TDeviceEvent& operator[] (_CORBA_ULong _index);
      const TDeviceEvent& operator[] (_CORBA_ULong _index) const;
      static TDeviceEvent* allocbuf(_CORBA_ULong _nelems);
      static void freebuf(TDeviceEvent* _b);

      void operator>>= (cdrStream &_s) const;
      void operator<<= (cdrStream &_s);

    protected:
      void NP_copybuffer(_CORBA_ULong _newmax);
      void NP_freebuf();
    };

    class TDeviceEventSeq_out;

    class TDeviceEventSeq_var {
    public:
      inline TDeviceEventSeq_var() : _pd_seq(0) {}
      inline TDeviceEventSeq_var(TDeviceEventSeq* _s) : _pd_seq(_s) {}
      inline TDeviceEventSeq_var(const TDeviceEventSeq_var& _s) {
        if( _s._pd_seq )  _pd_seq = new TDeviceEventSeq(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~TDeviceEventSeq_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline TDeviceEventSeq_var& operator = (TDeviceEventSeq* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline TDeviceEventSeq_var& operator = (const TDeviceEventSeq_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new TDeviceEventSeq;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline TDeviceEvent& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline TDeviceEventSeq* operator -> () { return _pd_seq; }
      inline const TDeviceEventSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator TDeviceEventSeq& () const { return *_pd_seq; }
#else
      inline operator const TDeviceEventSeq& () const { return *_pd_seq; }
      inline operator TDeviceEventSeq& () { return *_pd_seq; }
#endif
        
      inline const TDeviceEventSeq& in() const { return *_pd_seq; }
      inline TDeviceEventSeq&       inout()    { return *_pd_seq; }
      inline TDeviceEventSeq*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline TDeviceEventSeq* _retn() { TDeviceEventSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class TDeviceEventSeq_out;
      
    private:
      TDeviceEventSeq* _pd_seq;
    };

    class TDeviceEventSeq_out {
    public:
      inline TDeviceEventSeq_out(TDeviceEventSeq*& _s) : _data(_s) { _data = 0; }
      inline TDeviceEventSeq_out(TDeviceEventSeq_var& _s)
        : _data(_s._pd_seq) { _s = (TDeviceEventSeq*) 0; }
      inline TDeviceEventSeq_out(const TDeviceEventSeq_out& _s) : _data(_s._data) {}
      inline TDeviceEventSeq_out& operator = (const TDeviceEventSeq_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline TDeviceEventSeq_out& operator = (TDeviceEventSeq* _s) {
        _data = _s;
        return *this;
      }
      inline operator TDeviceEventSeq*&()  { return _data; }
      inline TDeviceEventSeq*& ptr()       { return _data; }
      inline TDeviceEventSeq* operator->() { return _data; }

      inline TDeviceEvent& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      TDeviceEventSeq*& _data;

    private:
      TDeviceEventSeq_out();
      TDeviceEventSeq_out& operator=(const TDeviceEventSeq_var&);
    };

    class TEventSeq_var;

    class TEventSeq : public _CORBA_Unbounded_Sequence_Forward< TEvent >  {
    public:
      typedef TEventSeq_var _var_type;

      inline TEventSeq() {}
      TEventSeq(const TEventSeq& _s);
      TEventSeq& operator=(const TEventSeq& _s);

      inline TEventSeq(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_Forward< TEvent > (_max) {}
      inline TEventSeq(_CORBA_ULong _max, _CORBA_ULong _len, TEvent* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_Forward< TEvent > (_max, _len, _val, _rel) {}

    

      virtual ~TEventSeq();

      TEvent& operator[] (_CORBA_ULong _index);
      const TEvent& operator[] (_CORBA_ULong _index) const;
      static TEvent* allocbuf(_CORBA_ULong _nelems);
      static void freebuf(TEvent* _b);

      void operator>>= (cdrStream &_s) const;
      void operator<<= (cdrStream &_s);

    protected:
      void NP_copybuffer(_CORBA_ULong _newmax);
      void NP_freebuf();
    };

    class TEventSeq_out;

    class TEventSeq_var {
    public:
      inline TEventSeq_var() : _pd_seq(0) {}
      inline TEventSeq_var(TEventSeq* _s) : _pd_seq(_s) {}
      inline TEventSeq_var(const TEventSeq_var& _s) {
        if( _s._pd_seq )  _pd_seq = new TEventSeq(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~TEventSeq_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline TEventSeq_var& operator = (TEventSeq* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline TEventSeq_var& operator = (const TEventSeq_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new TEventSeq;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline TEvent& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline TEventSeq* operator -> () { return _pd_seq; }
      inline const TEventSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator TEventSeq& () const { return *_pd_seq; }
#else
      inline operator const TEventSeq& () const { return *_pd_seq; }
      inline operator TEventSeq& () { return *_pd_seq; }
#endif
        
      inline const TEventSeq& in() const { return *_pd_seq; }
      inline TEventSeq&       inout()    { return *_pd_seq; }
      inline TEventSeq*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline TEventSeq* _retn() { TEventSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class TEventSeq_out;
      
    private:
      TEventSeq* _pd_seq;
    };

    class TEventSeq_out {
    public:
      inline TEventSeq_out(TEventSeq*& _s) : _data(_s) { _data = 0; }
      inline TEventSeq_out(TEventSeq_var& _s)
        : _data(_s._pd_seq) { _s = (TEventSeq*) 0; }
      inline TEventSeq_out(const TEventSeq_out& _s) : _data(_s._data) {}
      inline TEventSeq_out& operator = (const TEventSeq_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline TEventSeq_out& operator = (TEventSeq* _s) {
        _data = _s;
        return *this;
      }
      inline operator TEventSeq*&()  { return _data; }
      inline TEventSeq*& ptr()       { return _data; }
      inline TEventSeq* operator->() { return _data; }

      inline TEvent& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      TEventSeq*& _data;

    private:
      TEventSeq_out();
      TEventSeq_out& operator=(const TEventSeq_var&);
    };

    class TMeasurementSeq_var;

    class TMeasurementSeq : public _CORBA_Unbounded_Sequence_Forward< TMeasurement >  {
    public:
      typedef TMeasurementSeq_var _var_type;

      inline TMeasurementSeq() {}
      TMeasurementSeq(const TMeasurementSeq& _s);
      TMeasurementSeq& operator=(const TMeasurementSeq& _s);

      inline TMeasurementSeq(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_Forward< TMeasurement > (_max) {}
      inline TMeasurementSeq(_CORBA_ULong _max, _CORBA_ULong _len, TMeasurement* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_Forward< TMeasurement > (_max, _len, _val, _rel) {}

    

      virtual ~TMeasurementSeq();

      TMeasurement& operator[] (_CORBA_ULong _index);
      const TMeasurement& operator[] (_CORBA_ULong _index) const;
      static TMeasurement* allocbuf(_CORBA_ULong _nelems);
      static void freebuf(TMeasurement* _b);

      void operator>>= (cdrStream &_s) const;
      void operator<<= (cdrStream &_s);

    protected:
      void NP_copybuffer(_CORBA_ULong _newmax);
      void NP_freebuf();
    };

    class TMeasurementSeq_out;

    class TMeasurementSeq_var {
    public:
      inline TMeasurementSeq_var() : _pd_seq(0) {}
      inline TMeasurementSeq_var(TMeasurementSeq* _s) : _pd_seq(_s) {}
      inline TMeasurementSeq_var(const TMeasurementSeq_var& _s) {
        if( _s._pd_seq )  _pd_seq = new TMeasurementSeq(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~TMeasurementSeq_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline TMeasurementSeq_var& operator = (TMeasurementSeq* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline TMeasurementSeq_var& operator = (const TMeasurementSeq_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new TMeasurementSeq;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline TMeasurement& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline TMeasurementSeq* operator -> () { return _pd_seq; }
      inline const TMeasurementSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator TMeasurementSeq& () const { return *_pd_seq; }
#else
      inline operator const TMeasurementSeq& () const { return *_pd_seq; }
      inline operator TMeasurementSeq& () { return *_pd_seq; }
#endif
        
      inline const TMeasurementSeq& in() const { return *_pd_seq; }
      inline TMeasurementSeq&       inout()    { return *_pd_seq; }
      inline TMeasurementSeq*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline TMeasurementSeq* _retn() { TMeasurementSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class TMeasurementSeq_out;
      
    private:
      TMeasurementSeq* _pd_seq;
    };

    class TMeasurementSeq_out {
    public:
      inline TMeasurementSeq_out(TMeasurementSeq*& _s) : _data(_s) { _data = 0; }
      inline TMeasurementSeq_out(TMeasurementSeq_var& _s)
        : _data(_s._pd_seq) { _s = (TMeasurementSeq*) 0; }
      inline TMeasurementSeq_out(const TMeasurementSeq_out& _s) : _data(_s._data) {}
      inline TMeasurementSeq_out& operator = (const TMeasurementSeq_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline TMeasurementSeq_out& operator = (TMeasurementSeq* _s) {
        _data = _s;
        return *this;
      }
      inline operator TMeasurementSeq*&()  { return _data; }
      inline TMeasurementSeq*& ptr()       { return _data; }
      inline TMeasurementSeq* operator->() { return _data; }

      inline TMeasurement& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      TMeasurementSeq*& _data;

    private:
      TMeasurementSeq_out();
      TMeasurementSeq_out& operator=(const TMeasurementSeq_var&);
    };

    class TOctetSeq_var;

    class TOctetSeq : public _CORBA_Unbounded_Sequence_Octet {
    public:
      typedef TOctetSeq_var _var_type;
      inline TOctetSeq() {}
      inline TOctetSeq(const TOctetSeq& _s)
        : _CORBA_Unbounded_Sequence_Octet(_s) {}

      inline TOctetSeq(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_Octet(_max) {}
      inline TOctetSeq(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Octet* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_Octet(_max, _len, _val, _rel) {}

    

      inline TOctetSeq& operator = (const TOctetSeq& _s) {
        _CORBA_Unbounded_Sequence_Octet::operator=(_s);
        return *this;
      }
    };

    class TOctetSeq_out;

    class TOctetSeq_var {
    public:
      inline TOctetSeq_var() : _pd_seq(0) {}
      inline TOctetSeq_var(TOctetSeq* _s) : _pd_seq(_s) {}
      inline TOctetSeq_var(const TOctetSeq_var& _s) {
        if( _s._pd_seq )  _pd_seq = new TOctetSeq(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~TOctetSeq_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline TOctetSeq_var& operator = (TOctetSeq* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline TOctetSeq_var& operator = (const TOctetSeq_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new TOctetSeq;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline ::CORBA::Octet& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline TOctetSeq* operator -> () { return _pd_seq; }
      inline const TOctetSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator TOctetSeq& () const { return *_pd_seq; }
#else
      inline operator const TOctetSeq& () const { return *_pd_seq; }
      inline operator TOctetSeq& () { return *_pd_seq; }
#endif
        
      inline const TOctetSeq& in() const { return *_pd_seq; }
      inline TOctetSeq&       inout()    { return *_pd_seq; }
      inline TOctetSeq*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline TOctetSeq* _retn() { TOctetSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class TOctetSeq_out;
      
    private:
      TOctetSeq* _pd_seq;
    };

    class TOctetSeq_out {
    public:
      inline TOctetSeq_out(TOctetSeq*& _s) : _data(_s) { _data = 0; }
      inline TOctetSeq_out(TOctetSeq_var& _s)
        : _data(_s._pd_seq) { _s = (TOctetSeq*) 0; }
      inline TOctetSeq_out(const TOctetSeq_out& _s) : _data(_s._data) {}
      inline TOctetSeq_out& operator = (const TOctetSeq_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline TOctetSeq_out& operator = (TOctetSeq* _s) {
        _data = _s;
        return *this;
      }
      inline operator TOctetSeq*&()  { return _data; }
      inline TOctetSeq*& ptr()       { return _data; }
      inline TOctetSeq* operator->() { return _data; }

      inline ::CORBA::Octet& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      TOctetSeq*& _data;

    private:
      TOctetSeq_out();
      TOctetSeq_out& operator=(const TOctetSeq_var&);
    };

    class TOverwrittenSeq_var;

    class TOverwrittenSeq : public _CORBA_Unbounded_Sequence_Forward< TOverwritten >  {
    public:
      typedef TOverwrittenSeq_var _var_type;

      inline TOverwrittenSeq() {}
      TOverwrittenSeq(const TOverwrittenSeq& _s);
      TOverwrittenSeq& operator=(const TOverwrittenSeq& _s);

      inline TOverwrittenSeq(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_Forward< TOverwritten > (_max) {}
      inline TOverwrittenSeq(_CORBA_ULong _max, _CORBA_ULong _len, TOverwritten* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_Forward< TOverwritten > (_max, _len, _val, _rel) {}

    

      virtual ~TOverwrittenSeq();

      TOverwritten& operator[] (_CORBA_ULong _index);
      const TOverwritten& operator[] (_CORBA_ULong _index) const;
      static TOverwritten* allocbuf(_CORBA_ULong _nelems);
      static void freebuf(TOverwritten* _b);

      void operator>>= (cdrStream &_s) const;
      void operator<<= (cdrStream &_s);

    protected:
      void NP_copybuffer(_CORBA_ULong _newmax);
      void NP_freebuf();
    };

    class TOverwrittenSeq_out;

    class TOverwrittenSeq_var {
    public:
      inline TOverwrittenSeq_var() : _pd_seq(0) {}
      inline TOverwrittenSeq_var(TOverwrittenSeq* _s) : _pd_seq(_s) {}
      inline TOverwrittenSeq_var(const TOverwrittenSeq_var& _s) {
        if( _s._pd_seq )  _pd_seq = new TOverwrittenSeq(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~TOverwrittenSeq_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline TOverwrittenSeq_var& operator = (TOverwrittenSeq* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline TOverwrittenSeq_var& operator = (const TOverwrittenSeq_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new TOverwrittenSeq;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline TOverwritten& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline TOverwrittenSeq* operator -> () { return _pd_seq; }
      inline const TOverwrittenSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator TOverwrittenSeq& () const { return *_pd_seq; }
#else
      inline operator const TOverwrittenSeq& () const { return *_pd_seq; }
      inline operator TOverwrittenSeq& () { return *_pd_seq; }
#endif
        
      inline const TOverwrittenSeq& in() const { return *_pd_seq; }
      inline TOverwrittenSeq&       inout()    { return *_pd_seq; }
      inline TOverwrittenSeq*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline TOverwrittenSeq* _retn() { TOverwrittenSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class TOverwrittenSeq_out;
      
    private:
      TOverwrittenSeq* _pd_seq;
    };

    class TOverwrittenSeq_out {
    public:
      inline TOverwrittenSeq_out(TOverwrittenSeq*& _s) : _data(_s) { _data = 0; }
      inline TOverwrittenSeq_out(TOverwrittenSeq_var& _s)
        : _data(_s._pd_seq) { _s = (TOverwrittenSeq*) 0; }
      inline TOverwrittenSeq_out(const TOverwrittenSeq_out& _s) : _data(_s._data) {}
      inline TOverwrittenSeq_out& operator = (const TOverwrittenSeq_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline TOverwrittenSeq_out& operator = (TOverwrittenSeq* _s) {
        _data = _s;
        return *this;
      }
      inline operator TOverwrittenSeq*&()  { return _data; }
      inline TOverwrittenSeq*& ptr()       { return _data; }
      inline TOverwrittenSeq* operator->() { return _data; }

      inline TOverwritten& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      TOverwrittenSeq*& _data;

    private:
      TOverwrittenSeq_out();
      TOverwrittenSeq_out& operator=(const TOverwrittenSeq_var&);
    };

    class TPartnerSeq_var;

    class TPartnerSeq : public _CORBA_Unbounded_Sequence_Forward< TPartner >  {
    public:
      typedef TPartnerSeq_var _var_type;

      inline TPartnerSeq() {}
      TPartnerSeq(const TPartnerSeq& _s);
      TPartnerSeq& operator=(const TPartnerSeq& _s);

      inline TPartnerSeq(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_Forward< TPartner > (_max) {}
      inline TPartnerSeq(_CORBA_ULong _max, _CORBA_ULong _len, TPartner* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_Forward< TPartner > (_max, _len, _val, _rel) {}

    

      virtual ~TPartnerSeq();

      TPartner& operator[] (_CORBA_ULong _index);
      const TPartner& operator[] (_CORBA_ULong _index) const;
      static TPartner* allocbuf(_CORBA_ULong _nelems);
      static void freebuf(TPartner* _b);

      void operator>>= (cdrStream &_s) const;
      void operator<<= (cdrStream &_s);

    protected:
      void NP_copybuffer(_CORBA_ULong _newmax);
      void NP_freebuf();
    };

    class TPartnerSeq_out;

    class TPartnerSeq_var {
    public:
      inline TPartnerSeq_var() : _pd_seq(0) {}
      inline TPartnerSeq_var(TPartnerSeq* _s) : _pd_seq(_s) {}
      inline TPartnerSeq_var(const TPartnerSeq_var& _s) {
        if( _s._pd_seq )  _pd_seq = new TPartnerSeq(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~TPartnerSeq_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline TPartnerSeq_var& operator = (TPartnerSeq* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline TPartnerSeq_var& operator = (const TPartnerSeq_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new TPartnerSeq;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline TPartner& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline TPartnerSeq* operator -> () { return _pd_seq; }
      inline const TPartnerSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator TPartnerSeq& () const { return *_pd_seq; }
#else
      inline operator const TPartnerSeq& () const { return *_pd_seq; }
      inline operator TPartnerSeq& () { return *_pd_seq; }
#endif
        
      inline const TPartnerSeq& in() const { return *_pd_seq; }
      inline TPartnerSeq&       inout()    { return *_pd_seq; }
      inline TPartnerSeq*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline TPartnerSeq* _retn() { TPartnerSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class TPartnerSeq_out;
      
    private:
      TPartnerSeq* _pd_seq;
    };

    class TPartnerSeq_out {
    public:
      inline TPartnerSeq_out(TPartnerSeq*& _s) : _data(_s) { _data = 0; }
      inline TPartnerSeq_out(TPartnerSeq_var& _s)
        : _data(_s._pd_seq) { _s = (TPartnerSeq*) 0; }
      inline TPartnerSeq_out(const TPartnerSeq_out& _s) : _data(_s._data) {}
      inline TPartnerSeq_out& operator = (const TPartnerSeq_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline TPartnerSeq_out& operator = (TPartnerSeq* _s) {
        _data = _s;
        return *this;
      }
      inline operator TPartnerSeq*&()  { return _data; }
      inline TPartnerSeq*& ptr()       { return _data; }
      inline TPartnerSeq* operator->() { return _data; }

      inline TPartner& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      TPartnerSeq*& _data;

    private:
      TPartnerSeq_out();
      TPartnerSeq_out& operator=(const TPartnerSeq_var&);
    };

    class TRowSeq_var;

    class TRowSeq : public _CORBA_Unbounded_Sequence_Forward< TRow >  {
    public:
      typedef TRowSeq_var _var_type;

      inline TRowSeq() {}
      TRowSeq(const TRowSeq& _s);
      TRowSeq& operator=(const TRowSeq& _s);

      inline TRowSeq(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_Forward< TRow > (_max) {}
      inline TRowSeq(_CORBA_ULong _max, _CORBA_ULong _len, TRow* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_Forward< TRow > (_max, _len, _val, _rel) {}

    

      virtual ~TRowSeq();

      TRow& operator[] (_CORBA_ULong _index);
      const TRow& operator[] (_CORBA_ULong _index) const;
      static TRow* allocbuf(_CORBA_ULong _nelems);
      static void freebuf(TRow* _b);

      void operator>>= (cdrStream &_s) const;
      void operator<<= (cdrStream &_s);

    protected:
      void NP_copybuffer(_CORBA_ULong _newmax);
      void NP_freebuf();
    };

    class TRowSeq_out;

    class TRowSeq_var {
    public:
      inline TRowSeq_var() : _pd_seq(0) {}
      inline TRowSeq_var(TRowSeq* _s) : _pd_seq(_s) {}
      inline TRowSeq_var(const TRowSeq_var& _s) {
        if( _s._pd_seq )  _pd_seq = new TRowSeq(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~TRowSeq_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline TRowSeq_var& operator = (TRowSeq* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline TRowSeq_var& operator = (const TRowSeq_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new TRowSeq;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline TRow& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline TRowSeq* operator -> () { return _pd_seq; }
      inline const TRowSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator TRowSeq& () const { return *_pd_seq; }
#else
      inline operator const TRowSeq& () const { return *_pd_seq; }
      inline operator TRowSeq& () { return *_pd_seq; }
#endif
        
      inline const TRowSeq& in() const { return *_pd_seq; }
      inline TRowSeq&       inout()    { return *_pd_seq; }
      inline TRowSeq*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline TRowSeq* _retn() { TRowSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class TRowSeq_out;
      
    private:
      TRowSeq* _pd_seq;
    };

    class TRowSeq_out {
    public:
      inline TRowSeq_out(TRowSeq*& _s) : _data(_s) { _data = 0; }
      inline TRowSeq_out(TRowSeq_var& _s)
        : _data(_s._pd_seq) { _s = (TRowSeq*) 0; }
      inline TRowSeq_out(const TRowSeq_out& _s) : _data(_s._data) {}
      inline TRowSeq_out& operator = (const TRowSeq_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline TRowSeq_out& operator = (TRowSeq* _s) {
        _data = _s;
        return *this;
      }
      inline operator TRowSeq*&()  { return _data; }
      inline TRowSeq*& ptr()       { return _data; }
      inline TRowSeq* operator->() { return _data; }

      inline TRow& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      TRowSeq*& _data;

    private:
      TRowSeq_out();
      TRowSeq_out& operator=(const TRowSeq_var&);
    };

    class TshortSeq_var;

    class TshortSeq : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 >  {
    public:
      typedef TshortSeq_var _var_type;
      inline TshortSeq() {}
      inline TshortSeq(const TshortSeq& _s)
        : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 > (_s) {}

      inline TshortSeq(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 > (_max) {}
      inline TshortSeq(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::UShort* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 > (_max, _len, _val, _rel) {}

    

      inline TshortSeq& operator = (const TshortSeq& _s) {
        _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 > ::operator=(_s);
        return *this;
      }
    };

    class TshortSeq_out;

    class TshortSeq_var {
    public:
      inline TshortSeq_var() : _pd_seq(0) {}
      inline TshortSeq_var(TshortSeq* _s) : _pd_seq(_s) {}
      inline TshortSeq_var(const TshortSeq_var& _s) {
        if( _s._pd_seq )  _pd_seq = new TshortSeq(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~TshortSeq_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline TshortSeq_var& operator = (TshortSeq* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline TshortSeq_var& operator = (const TshortSeq_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new TshortSeq;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline ::CORBA::UShort& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline TshortSeq* operator -> () { return _pd_seq; }
      inline const TshortSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator TshortSeq& () const { return *_pd_seq; }
#else
      inline operator const TshortSeq& () const { return *_pd_seq; }
      inline operator TshortSeq& () { return *_pd_seq; }
#endif
        
      inline const TshortSeq& in() const { return *_pd_seq; }
      inline TshortSeq&       inout()    { return *_pd_seq; }
      inline TshortSeq*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline TshortSeq* _retn() { TshortSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class TshortSeq_out;
      
    private:
      TshortSeq* _pd_seq;
    };

    class TshortSeq_out {
    public:
      inline TshortSeq_out(TshortSeq*& _s) : _data(_s) { _data = 0; }
      inline TshortSeq_out(TshortSeq_var& _s)
        : _data(_s._pd_seq) { _s = (TshortSeq*) 0; }
      inline TshortSeq_out(const TshortSeq_out& _s) : _data(_s._data) {}
      inline TshortSeq_out& operator = (const TshortSeq_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline TshortSeq_out& operator = (TshortSeq* _s) {
        _data = _s;
        return *this;
      }
      inline operator TshortSeq*&()  { return _data; }
      inline TshortSeq*& ptr()       { return _data; }
      inline TshortSeq* operator->() { return _data; }

      inline ::CORBA::UShort& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      TshortSeq*& _data;

    private:
      TshortSeq_out();
      TshortSeq_out& operator=(const TshortSeq_var&);
    };

    class TStringSeq_var;

    class TStringSeq : public _CORBA_Unbounded_Sequence_String {
    public:
      typedef TStringSeq_var _var_type;
      inline TStringSeq() {}
      inline TStringSeq(const TStringSeq& _s)
        : _CORBA_Unbounded_Sequence_String(_s) {}

      inline TStringSeq(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_String(_max) {}
      inline TStringSeq(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_String(_max, _len, _val, _rel) {}

    

      inline TStringSeq& operator = (const TStringSeq& _s) {
        _CORBA_Unbounded_Sequence_String::operator=(_s);
        return *this;
      }
    };

    class TStringSeq_out;

    class TStringSeq_var {
    public:
      inline TStringSeq_var() : _pd_seq(0) {}
      inline TStringSeq_var(TStringSeq* _s) : _pd_seq(_s) {}
      inline TStringSeq_var(const TStringSeq_var& _s) {
        if( _s._pd_seq )  _pd_seq = new TStringSeq(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~TStringSeq_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline TStringSeq_var& operator = (TStringSeq* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline TStringSeq_var& operator = (const TStringSeq_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new TStringSeq;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline _CORBA_String_element operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline TStringSeq* operator -> () { return _pd_seq; }
      inline const TStringSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator TStringSeq& () const { return *_pd_seq; }
#else
      inline operator const TStringSeq& () const { return *_pd_seq; }
      inline operator TStringSeq& () { return *_pd_seq; }
#endif
        
      inline const TStringSeq& in() const { return *_pd_seq; }
      inline TStringSeq&       inout()    { return *_pd_seq; }
      inline TStringSeq*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline TStringSeq* _retn() { TStringSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class TStringSeq_out;
      
    private:
      TStringSeq* _pd_seq;
    };

    class TStringSeq_out {
    public:
      inline TStringSeq_out(TStringSeq*& _s) : _data(_s) { _data = 0; }
      inline TStringSeq_out(TStringSeq_var& _s)
        : _data(_s._pd_seq) { _s = (TStringSeq*) 0; }
      inline TStringSeq_out(const TStringSeq_out& _s) : _data(_s._data) {}
      inline TStringSeq_out& operator = (const TStringSeq_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline TStringSeq_out& operator = (TStringSeq* _s) {
        _data = _s;
        return *this;
      }
      inline operator TStringSeq*&()  { return _data; }
      inline TStringSeq*& ptr()       { return _data; }
      inline TStringSeq* operator->() { return _data; }

      inline _CORBA_String_element operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      TStringSeq*& _data;

    private:
      TStringSeq_out();
      TStringSeq_out& operator=(const TStringSeq_var&);
    };

    class TValMixedSeq_var;

    class TValMixedSeq : public _CORBA_Unbounded_Sequence_Forward< TValMixed >  {
    public:
      typedef TValMixedSeq_var _var_type;

      inline TValMixedSeq() {}
      TValMixedSeq(const TValMixedSeq& _s);
      TValMixedSeq& operator=(const TValMixedSeq& _s);

      inline TValMixedSeq(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_Forward< TValMixed > (_max) {}
      inline TValMixedSeq(_CORBA_ULong _max, _CORBA_ULong _len, TValMixed* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_Forward< TValMixed > (_max, _len, _val, _rel) {}

    

      virtual ~TValMixedSeq();

      TValMixed& operator[] (_CORBA_ULong _index);
      const TValMixed& operator[] (_CORBA_ULong _index) const;
      static TValMixed* allocbuf(_CORBA_ULong _nelems);
      static void freebuf(TValMixed* _b);

      void operator>>= (cdrStream &_s) const;
      void operator<<= (cdrStream &_s);

    protected:
      void NP_copybuffer(_CORBA_ULong _newmax);
      void NP_freebuf();
    };

    class TValMixedSeq_out;

    class TValMixedSeq_var {
    public:
      inline TValMixedSeq_var() : _pd_seq(0) {}
      inline TValMixedSeq_var(TValMixedSeq* _s) : _pd_seq(_s) {}
      inline TValMixedSeq_var(const TValMixedSeq_var& _s) {
        if( _s._pd_seq )  _pd_seq = new TValMixedSeq(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~TValMixedSeq_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline TValMixedSeq_var& operator = (TValMixedSeq* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline TValMixedSeq_var& operator = (const TValMixedSeq_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new TValMixedSeq;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline TValMixed& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline TValMixedSeq* operator -> () { return _pd_seq; }
      inline const TValMixedSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator TValMixedSeq& () const { return *_pd_seq; }
#else
      inline operator const TValMixedSeq& () const { return *_pd_seq; }
      inline operator TValMixedSeq& () { return *_pd_seq; }
#endif
        
      inline const TValMixedSeq& in() const { return *_pd_seq; }
      inline TValMixedSeq&       inout()    { return *_pd_seq; }
      inline TValMixedSeq*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline TValMixedSeq* _retn() { TValMixedSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class TValMixedSeq_out;
      
    private:
      TValMixedSeq* _pd_seq;
    };

    class TValMixedSeq_out {
    public:
      inline TValMixedSeq_out(TValMixedSeq*& _s) : _data(_s) { _data = 0; }
      inline TValMixedSeq_out(TValMixedSeq_var& _s)
        : _data(_s._pd_seq) { _s = (TValMixedSeq*) 0; }
      inline TValMixedSeq_out(const TValMixedSeq_out& _s) : _data(_s._data) {}
      inline TValMixedSeq_out& operator = (const TValMixedSeq_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline TValMixedSeq_out& operator = (TValMixedSeq* _s) {
        _data = _s;
        return *this;
      }
      inline operator TValMixedSeq*&()  { return _data; }
      inline TValMixedSeq*& ptr()       { return _data; }
      inline TValMixedSeq* operator->() { return _data; }

      inline TValMixed& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      TValMixedSeq*& _data;

    private:
      TValMixedSeq_out();
      TValMixedSeq_out& operator=(const TValMixedSeq_var&);
    };

    class TVariableSeq_var;

    class TVariableSeq : public _CORBA_Unbounded_Sequence_Forward< TVariable >  {
    public:
      typedef TVariableSeq_var _var_type;

      inline TVariableSeq() {}
      TVariableSeq(const TVariableSeq& _s);
      TVariableSeq& operator=(const TVariableSeq& _s);

      inline TVariableSeq(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_Forward< TVariable > (_max) {}
      inline TVariableSeq(_CORBA_ULong _max, _CORBA_ULong _len, TVariable* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_Forward< TVariable > (_max, _len, _val, _rel) {}

    

      virtual ~TVariableSeq();

      TVariable& operator[] (_CORBA_ULong _index);
      const TVariable& operator[] (_CORBA_ULong _index) const;
      static TVariable* allocbuf(_CORBA_ULong _nelems);
      static void freebuf(TVariable* _b);

      void operator>>= (cdrStream &_s) const;
      void operator<<= (cdrStream &_s);

    protected:
      void NP_copybuffer(_CORBA_ULong _newmax);
      void NP_freebuf();
    };

    class TVariableSeq_out;

    class TVariableSeq_var {
    public:
      inline TVariableSeq_var() : _pd_seq(0) {}
      inline TVariableSeq_var(TVariableSeq* _s) : _pd_seq(_s) {}
      inline TVariableSeq_var(const TVariableSeq_var& _s) {
        if( _s._pd_seq )  _pd_seq = new TVariableSeq(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~TVariableSeq_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline TVariableSeq_var& operator = (TVariableSeq* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline TVariableSeq_var& operator = (const TVariableSeq_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new TVariableSeq;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline TVariable& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline TVariableSeq* operator -> () { return _pd_seq; }
      inline const TVariableSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator TVariableSeq& () const { return *_pd_seq; }
#else
      inline operator const TVariableSeq& () const { return *_pd_seq; }
      inline operator TVariableSeq& () { return *_pd_seq; }
#endif
        
      inline const TVariableSeq& in() const { return *_pd_seq; }
      inline TVariableSeq&       inout()    { return *_pd_seq; }
      inline TVariableSeq*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline TVariableSeq* _retn() { TVariableSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class TVariableSeq_out;
      
    private:
      TVariableSeq* _pd_seq;
    };

    class TVariableSeq_out {
    public:
      inline TVariableSeq_out(TVariableSeq*& _s) : _data(_s) { _data = 0; }
      inline TVariableSeq_out(TVariableSeq_var& _s)
        : _data(_s._pd_seq) { _s = (TVariableSeq*) 0; }
      inline TVariableSeq_out(const TVariableSeq_out& _s) : _data(_s._data) {}
      inline TVariableSeq_out& operator = (const TVariableSeq_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline TVariableSeq_out& operator = (TVariableSeq* _s) {
        _data = _s;
        return *this;
      }
      inline operator TVariableSeq*&()  { return _data; }
      inline TVariableSeq*& ptr()       { return _data; }
      inline TVariableSeq* operator->() { return _data; }

      inline TVariable& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      TVariableSeq*& _data;

    private:
      TVariableSeq_out();
      TVariableSeq_out& operator=(const TVariableSeq_var&);
    };

    class TVarMixedSeq_var;

    class TVarMixedSeq : public _CORBA_Unbounded_Sequence_Forward< TVarMixed >  {
    public:
      typedef TVarMixedSeq_var _var_type;

      inline TVarMixedSeq() {}
      TVarMixedSeq(const TVarMixedSeq& _s);
      TVarMixedSeq& operator=(const TVarMixedSeq& _s);

      inline TVarMixedSeq(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_Forward< TVarMixed > (_max) {}
      inline TVarMixedSeq(_CORBA_ULong _max, _CORBA_ULong _len, TVarMixed* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_Forward< TVarMixed > (_max, _len, _val, _rel) {}

    

      virtual ~TVarMixedSeq();

      TVarMixed& operator[] (_CORBA_ULong _index);
      const TVarMixed& operator[] (_CORBA_ULong _index) const;
      static TVarMixed* allocbuf(_CORBA_ULong _nelems);
      static void freebuf(TVarMixed* _b);

      void operator>>= (cdrStream &_s) const;
      void operator<<= (cdrStream &_s);

    protected:
      void NP_copybuffer(_CORBA_ULong _newmax);
      void NP_freebuf();
    };

    class TVarMixedSeq_out;

    class TVarMixedSeq_var {
    public:
      inline TVarMixedSeq_var() : _pd_seq(0) {}
      inline TVarMixedSeq_var(TVarMixedSeq* _s) : _pd_seq(_s) {}
      inline TVarMixedSeq_var(const TVarMixedSeq_var& _s) {
        if( _s._pd_seq )  _pd_seq = new TVarMixedSeq(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~TVarMixedSeq_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline TVarMixedSeq_var& operator = (TVarMixedSeq* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline TVarMixedSeq_var& operator = (const TVarMixedSeq_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new TVarMixedSeq;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline TVarMixed& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline TVarMixedSeq* operator -> () { return _pd_seq; }
      inline const TVarMixedSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator TVarMixedSeq& () const { return *_pd_seq; }
#else
      inline operator const TVarMixedSeq& () const { return *_pd_seq; }
      inline operator TVarMixedSeq& () { return *_pd_seq; }
#endif
        
      inline const TVarMixedSeq& in() const { return *_pd_seq; }
      inline TVarMixedSeq&       inout()    { return *_pd_seq; }
      inline TVarMixedSeq*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline TVarMixedSeq* _retn() { TVarMixedSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class TVarMixedSeq_out;
      
    private:
      TVarMixedSeq* _pd_seq;
    };

    class TVarMixedSeq_out {
    public:
      inline TVarMixedSeq_out(TVarMixedSeq*& _s) : _data(_s) { _data = 0; }
      inline TVarMixedSeq_out(TVarMixedSeq_var& _s)
        : _data(_s._pd_seq) { _s = (TVarMixedSeq*) 0; }
      inline TVarMixedSeq_out(const TVarMixedSeq_out& _s) : _data(_s._data) {}
      inline TVarMixedSeq_out& operator = (const TVarMixedSeq_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline TVarMixedSeq_out& operator = (TVarMixedSeq* _s) {
        _data = _s;
        return *this;
      }
      inline operator TVarMixedSeq*&()  { return _data; }
      inline TVarMixedSeq*& ptr()       { return _data; }
      inline TVarMixedSeq* operator->() { return _data; }

      inline TVarMixed& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      TVarMixedSeq*& _data;

    private:
      TVarMixedSeq_out();
      TVarMixedSeq_out& operator=(const TVarMixedSeq_var&);
    };

    enum TChannelType { Output, Input, BiDirectional, Unknown /*, __max_TChannelType=0xffffffff */ };
    typedef TChannelType& TChannelType_out;

    enum TMessageType { LoadingError, PlayingError, DeviceError /*, __max_TMessageType=0xffffffff */ };
    typedef TMessageType& TMessageType_out;

    enum TStatusLevel { LevelStopped, LevelRunning, LevelPaused, LevelError, LevelParsing, LevelParsed, LevelUnparsed /*, __max_TStatusLevel=0xffffffff */ };
    typedef TStatusLevel& TStatusLevel_out;

    enum TType { TypeNumber, TypeString, TypeChannel, TypeList, TypeObject /*, __max_TType=0xffffffff */ };
    typedef TType& TType_out;

    enum DeviceStatus { EventsEmpty, EventsLoading, EventsLoaded, PreparingToPlay, Playing, Paused /*, __max_DeviceStatus=0xffffffff */ };
    typedef DeviceStatus& DeviceStatus_out;

    enum TData { DataBoolean, DataOctet, DataLong, DataDouble, DataString, DataPicture, DataVector, DataFile, DataNone /*, __max_TData=0xffffffff */ };
    typedef TData& TData_out;

    enum TValue { ValueNumber, ValueString, ValueVector, ValueNone /*, __max_TValue=0xffffffff */ };
    typedef TValue& TValue_out;

#ifndef __STI_mTypes_mTNetworkFile__
#define __STI_mTypes_mTNetworkFile__

    class TNetworkFile;
    class _objref_TNetworkFile;
    class _impl_TNetworkFile;
    
    typedef _objref_TNetworkFile* TNetworkFile_ptr;
    typedef TNetworkFile_ptr TNetworkFileRef;

    class TNetworkFile_Helper {
    public:
      typedef TNetworkFile_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_TNetworkFile, TNetworkFile_Helper> TNetworkFile_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_TNetworkFile,TNetworkFile_Helper > TNetworkFile_out;

#endif

    // interface TNetworkFile
    class TNetworkFile {
    public:
      // Declarations for this interface type.
      typedef TNetworkFile_ptr _ptr_type;
      typedef TNetworkFile_var _var_type;

      static _ptr_type _duplicate(_ptr_type);
      static _ptr_type _narrow(::CORBA::Object_ptr);
      static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
      
      static _ptr_type _nil();

      static inline void _marshalObjRef(_ptr_type, cdrStream&);

      static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
        omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static _core_attr const char* _PD_repoId;

      // Other IDL defined within this scope.
      
    };

    class _objref_TNetworkFile :
      public virtual ::CORBA::Object,
      public virtual omniObjRef
    {
    public:
      ::CORBA::Boolean getBytes(::CORBA::Long startByte, ::CORBA::Long numBytes, TOctetSeq_out bytes);
      ::CORBA::Boolean deleteRemoteFile();
      char* fileName();
      ::CORBA::Long length();

      inline _objref_TNetworkFile()  { _PR_setobj(0); }  // nil
      _objref_TNetworkFile(omniIOR*, omniIdentity*);

    protected:
      virtual ~_objref_TNetworkFile();

      
    private:
      virtual void* _ptrToObjRef(const char*);

      _objref_TNetworkFile(const _objref_TNetworkFile&);
      _objref_TNetworkFile& operator = (const _objref_TNetworkFile&);
      // not implemented

      friend class TNetworkFile;
    };

    class _pof_TNetworkFile : public _OMNI_NS(proxyObjectFactory) {
    public:
      inline _pof_TNetworkFile() : _OMNI_NS(proxyObjectFactory)(TNetworkFile::_PD_repoId) {}
      virtual ~_pof_TNetworkFile();

      virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
      virtual _CORBA_Boolean is_a(const char*) const;
    };

    class _impl_TNetworkFile :
      public virtual omniServant
    {
    public:
      virtual ~_impl_TNetworkFile();

      virtual ::CORBA::Boolean getBytes(::CORBA::Long startByte, ::CORBA::Long numBytes, TOctetSeq_out bytes) = 0;
      virtual ::CORBA::Boolean deleteRemoteFile() = 0;
      virtual char* fileName() = 0;
      virtual ::CORBA::Long length() = 0;
      
    public:  // Really protected, workaround for xlC
      virtual _CORBA_Boolean _dispatch(omniCallHandle&);

    private:
      virtual void* _ptrToInterface(const char*);
      virtual const char* _mostDerivedRepoId();
      
    };


    class TNetworkFileSeq_var;

    class TNetworkFileSeq : public _CORBA_Unbounded_Sequence_ObjRef< _objref_TNetworkFile, _CORBA_ObjRef_Element< _objref_TNetworkFile, TNetworkFile_Helper> , TNetworkFile_Helper >  {
    public:
      typedef TNetworkFileSeq_var _var_type;
      inline TNetworkFileSeq() {}
      inline TNetworkFileSeq(const TNetworkFileSeq& _s)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_TNetworkFile, _CORBA_ObjRef_Element< _objref_TNetworkFile, TNetworkFile_Helper> , TNetworkFile_Helper > (_s) {}

      inline TNetworkFileSeq(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_TNetworkFile, _CORBA_ObjRef_Element< _objref_TNetworkFile, TNetworkFile_Helper> , TNetworkFile_Helper > (_max) {}
      inline TNetworkFileSeq(_CORBA_ULong _max, _CORBA_ULong _len, TNetworkFile_ptr* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_TNetworkFile, _CORBA_ObjRef_Element< _objref_TNetworkFile, TNetworkFile_Helper> , TNetworkFile_Helper > (_max, _len, _val, _rel) {}

    

      inline TNetworkFileSeq& operator = (const TNetworkFileSeq& _s) {
        _CORBA_Unbounded_Sequence_ObjRef< _objref_TNetworkFile, _CORBA_ObjRef_Element< _objref_TNetworkFile, TNetworkFile_Helper> , TNetworkFile_Helper > ::operator=(_s);
        return *this;
      }
    };

    class TNetworkFileSeq_out;

    class TNetworkFileSeq_var {
    public:
      inline TNetworkFileSeq_var() : _pd_seq(0) {}
      inline TNetworkFileSeq_var(TNetworkFileSeq* _s) : _pd_seq(_s) {}
      inline TNetworkFileSeq_var(const TNetworkFileSeq_var& _s) {
        if( _s._pd_seq )  _pd_seq = new TNetworkFileSeq(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~TNetworkFileSeq_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline TNetworkFileSeq_var& operator = (TNetworkFileSeq* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline TNetworkFileSeq_var& operator = (const TNetworkFileSeq_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new TNetworkFileSeq;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline _CORBA_ObjRef_Element< _objref_TNetworkFile, TNetworkFile_Helper>  operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline TNetworkFileSeq* operator -> () { return _pd_seq; }
      inline const TNetworkFileSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator TNetworkFileSeq& () const { return *_pd_seq; }
#else
      inline operator const TNetworkFileSeq& () const { return *_pd_seq; }
      inline operator TNetworkFileSeq& () { return *_pd_seq; }
#endif
        
      inline const TNetworkFileSeq& in() const { return *_pd_seq; }
      inline TNetworkFileSeq&       inout()    { return *_pd_seq; }
      inline TNetworkFileSeq*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline TNetworkFileSeq* _retn() { TNetworkFileSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class TNetworkFileSeq_out;
      
    private:
      TNetworkFileSeq* _pd_seq;
    };

    class TNetworkFileSeq_out {
    public:
      inline TNetworkFileSeq_out(TNetworkFileSeq*& _s) : _data(_s) { _data = 0; }
      inline TNetworkFileSeq_out(TNetworkFileSeq_var& _s)
        : _data(_s._pd_seq) { _s = (TNetworkFileSeq*) 0; }
      inline TNetworkFileSeq_out(const TNetworkFileSeq_out& _s) : _data(_s._data) {}
      inline TNetworkFileSeq_out& operator = (const TNetworkFileSeq_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline TNetworkFileSeq_out& operator = (TNetworkFileSeq* _s) {
        _data = _s;
        return *this;
      }
      inline operator TNetworkFileSeq*&()  { return _data; }
      inline TNetworkFileSeq*& ptr()       { return _data; }
      inline TNetworkFileSeq* operator->() { return _data; }

      inline _CORBA_ObjRef_Element< _objref_TNetworkFile, TNetworkFile_Helper>  operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      TNetworkFileSeq*& _data;

    private:
      TNetworkFileSeq_out();
      TNetworkFileSeq_out& operator=(const TNetworkFileSeq_var&);
    };

    struct TLogFile {
      typedef _CORBA_ConstrType_Variable_Var<TLogFile> _var_type;

      
      _CORBA_ObjRef_Member< _objref_TNetworkFile, TNetworkFile_Helper>  logFile;

      ::CORBA::Long startTime;

      ::CORBA::Long endTime;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef TLogFile::_var_type TLogFile_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< TLogFile,TLogFile_var > TLogFile_out;

    class TLogFileSeq_var;

    class TLogFileSeq : public _CORBA_Unbounded_Sequence< TLogFile >  {
    public:
      typedef TLogFileSeq_var _var_type;
      inline TLogFileSeq() {}
      inline TLogFileSeq(const TLogFileSeq& _s)
        : _CORBA_Unbounded_Sequence< TLogFile > (_s) {}

      inline TLogFileSeq(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< TLogFile > (_max) {}
      inline TLogFileSeq(_CORBA_ULong _max, _CORBA_ULong _len, TLogFile* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< TLogFile > (_max, _len, _val, _rel) {}

    

      inline TLogFileSeq& operator = (const TLogFileSeq& _s) {
        _CORBA_Unbounded_Sequence< TLogFile > ::operator=(_s);
        return *this;
      }
    };

    class TLogFileSeq_out;

    class TLogFileSeq_var {
    public:
      inline TLogFileSeq_var() : _pd_seq(0) {}
      inline TLogFileSeq_var(TLogFileSeq* _s) : _pd_seq(_s) {}
      inline TLogFileSeq_var(const TLogFileSeq_var& _s) {
        if( _s._pd_seq )  _pd_seq = new TLogFileSeq(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~TLogFileSeq_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline TLogFileSeq_var& operator = (TLogFileSeq* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline TLogFileSeq_var& operator = (const TLogFileSeq_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new TLogFileSeq;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline TLogFile& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline TLogFileSeq* operator -> () { return _pd_seq; }
      inline const TLogFileSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator TLogFileSeq& () const { return *_pd_seq; }
#else
      inline operator const TLogFileSeq& () const { return *_pd_seq; }
      inline operator TLogFileSeq& () { return *_pd_seq; }
#endif
        
      inline const TLogFileSeq& in() const { return *_pd_seq; }
      inline TLogFileSeq&       inout()    { return *_pd_seq; }
      inline TLogFileSeq*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline TLogFileSeq* _retn() { TLogFileSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class TLogFileSeq_out;
      
    private:
      TLogFileSeq* _pd_seq;
    };

    class TLogFileSeq_out {
    public:
      inline TLogFileSeq_out(TLogFileSeq*& _s) : _data(_s) { _data = 0; }
      inline TLogFileSeq_out(TLogFileSeq_var& _s)
        : _data(_s._pd_seq) { _s = (TLogFileSeq*) 0; }
      inline TLogFileSeq_out(const TLogFileSeq_out& _s) : _data(_s._data) {}
      inline TLogFileSeq_out& operator = (const TLogFileSeq_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline TLogFileSeq_out& operator = (TLogFileSeq* _s) {
        _data = _s;
        return *this;
      }
      inline operator TLogFileSeq*&()  { return _data; }
      inline TLogFileSeq*& ptr()       { return _data; }
      inline TLogFileSeq* operator->() { return _data; }

      inline TLogFile& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      TLogFileSeq*& _data;

    private:
      TLogFileSeq_out();
      TLogFileSeq_out& operator=(const TLogFileSeq_var&);
    };

    struct TDevice {
      typedef _CORBA_ConstrType_Variable_Var<TDevice> _var_type;

      
      ::CORBA::String_member deviceName;

      ::CORBA::String_member address;

      ::CORBA::UShort moduleNum;

      ::CORBA::String_member deviceID;

      ::CORBA::String_member deviceContext;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef TDevice::_var_type TDevice_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< TDevice,TDevice_var > TDevice_out;

    struct TFile {
      typedef _CORBA_ConstrType_Variable_Var<TFile> _var_type;

      
      ::CORBA::String_member fileName;

      ::CORBA::String_member fileServerAddress;

      ::CORBA::String_member fileServerDirectory;

      ::CORBA::String_member description;

      _CORBA_ObjRef_Member< _objref_TNetworkFile, TNetworkFile_Helper>  networkFile;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef TFile::_var_type TFile_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< TFile,TFile_var > TFile_out;

    struct TPartner {
      typedef _CORBA_ConstrType_Variable_Var<TPartner> _var_type;

      
      ::CORBA::String_member partnerDeviceID;

      ::CORBA::String_member deviceName;

      ::CORBA::String_member ipAddress;

      ::CORBA::UShort moduleNum;

      ::CORBA::Boolean isRequired;

      ::CORBA::Boolean isEventTarget;

      ::CORBA::Boolean isMutual;

      ::CORBA::Boolean isRegistered;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef TPartner::_var_type TPartner_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< TPartner,TPartner_var > TPartner_out;

    struct TPicture {
      typedef _CORBA_ConstrType_Variable_Var<TPicture> _var_type;

      
      ::CORBA::UShort rowLength;

      TshortSeq pixels;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef TPicture::_var_type TPicture_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< TPicture,TPicture_var > TPicture_out;

    struct TPosition {
      typedef _CORBA_ConstrType_Fix_Var<TPosition> _var_type;

      
      ::CORBA::UShort file;

      ::CORBA::ULong line;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef TPosition::_var_type TPosition_var;

    typedef TPosition& TPosition_out;

    struct TDevicePosition {
      typedef _CORBA_ConstrType_Variable_Var<TDevicePosition> _var_type;

      
      ::CORBA::String_member file;

      ::CORBA::ULong line;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef TDevicePosition::_var_type TDevicePosition_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< TDevicePosition,TDevicePosition_var > TDevicePosition_out;

    class TValMixed {
    public:

      typedef _CORBA_ConstrType_Variable_Var<TValMixed> _var_type;

      

      TValMixed(): _pd__initialised(0) {
        
      }
      
      TValMixed(const TValMixed& _value) {
        _pd__initialised = _value._pd__initialised;
        switch(_value._pd__d) {
          case ValueNumber: number(_value._pd_number); break;

          case ValueString: stringVal(_value._pd_stringVal); break;

          case ValueVector: vector(_value._pd_vector); break;

          case ValueNone: emptyValue(_value._pd_emptyValue); break;

            default: break;

        
        }
        _pd__d = _value._pd__d;
    
      }

      ~TValMixed() {}

      TValMixed& operator=(const TValMixed& _value) {
        _pd__initialised = _value._pd__initialised;
        switch(_value._pd__d) {
          case ValueNumber: number(_value._pd_number); break;

          case ValueString: stringVal(_value._pd_stringVal); break;

          case ValueVector: vector(_value._pd_vector); break;

          case ValueNone: emptyValue(_value._pd_emptyValue); break;

            default: break;

        
        }
        _pd__d = _value._pd__d;
    
        return *this;
      }

      TValue _d() const { return _pd__d;}
      void _d(TValue _value){
        // illegal to set discriminator before making a member active
        if (!_pd__initialised)
          OMNIORB_THROW(BAD_PARAM,_OMNI_NS(BAD_PARAM_InvalidUnionDiscValue),::CORBA::COMPLETED_NO);

        if (_value == _pd__d) return; // no change

        switch (_pd__d){
          case ValueNumber: goto fail;
          case ValueString: goto fail;
          case ValueVector: goto fail;
          case ValueNone: goto fail;
          default: goto fail;

        };
        

        fail:
        OMNIORB_THROW(BAD_PARAM,_OMNI_NS(BAD_PARAM_InvalidUnionDiscValue),::CORBA::COMPLETED_NO);


    
      }

      

      ::CORBA::Double number () const { return _pd_number; }
      void number (::CORBA::Double  _value) {
        _pd__initialised = 1;
        _pd__d = ValueNumber;
        _pd__default = 0;
        _pd_number = _value;
      }

      const char * stringVal () const { return (const char*) _pd_stringVal; }
      void stringVal(char* _value) {
        _pd__initialised = 1;
        _pd__d = ValueString;
        _pd__default = 0;
        _pd_stringVal = _value;
      }
      void stringVal(const char*  _value) {
        _pd__initialised = 1;
        _pd__d = ValueString;
        _pd__default = 0;
        _pd_stringVal = _value;
      }
      void stringVal(const ::CORBA::String_var& _value) {
        _pd__initialised = 1;
        _pd__d = ValueString;
        _pd__default = 0;
        _pd_stringVal = _value;
      }
      void stringVal(const ::CORBA::String_member& _value) {
        _pd__initialised = 1;
        _pd__d = ValueString;
        _pd__default = 0;
        _pd_stringVal = _value;
      }

      const TValMixedSeq &vector () const { return _pd_vector; }
      TValMixedSeq &vector () { return _pd_vector; }
      void vector (const TValMixedSeq& _value) {
        _pd__initialised = 1;
        _pd__d = ValueVector;
        _pd__default = 0;
        _pd_vector = _value;
      }

      ::CORBA::Boolean emptyValue () const { return _pd_emptyValue; }
      void emptyValue (::CORBA::Boolean  _value) {
        _pd__initialised = 1;
        _pd__d = ValueNone;
        _pd__default = 0;
        _pd_emptyValue = _value;
      }

    
      
      void operator>>= (cdrStream&) const;
      void operator<<= (cdrStream&);

    private:
      TValue _pd__d;
      _CORBA_Boolean _pd__default;
      _CORBA_Boolean _pd__initialised;

      union {
        
#ifndef USING_PROXY_FLOAT
          ::CORBA::Double _pd_number;
#endif

        ::CORBA::Boolean _pd_emptyValue;


      };

    
      
#ifdef USING_PROXY_FLOAT
        ::CORBA::Double _pd_number;
#endif

      ::CORBA::String_member _pd_stringVal;

      TValMixedSeq _pd_vector;

    
    };

    typedef TValMixed::_var_type TValMixed_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< TValMixed,TValMixed_var > TValMixed_out;

    class TDataMixed {
    public:

      typedef _CORBA_ConstrType_Variable_Var<TDataMixed> _var_type;

      

      TDataMixed(): _pd__initialised(0) {
        
      }
      
      TDataMixed(const TDataMixed& _value) {
        _pd__initialised = _value._pd__initialised;
        switch(_value._pd__d) {
          case DataBoolean: booleanVal(_value._pd_booleanVal); break;

          case DataOctet: octetVal(_value._pd_octetVal); break;

          case DataLong: longVal(_value._pd_longVal); break;

          case DataDouble: doubleVal(_value._pd_doubleVal); break;

          case DataString: stringVal(_value._pd_stringVal); break;

          case DataPicture: picture(_value._pd_picture); break;

          case DataVector: vector(_value._pd_vector); break;

          case DataFile: file(_value._pd_file); break;

          case DataNone: outVal(_value._pd_outVal); break;

            default: break;

        
        }
        _pd__d = _value._pd__d;
    
      }

      ~TDataMixed() {}

      TDataMixed& operator=(const TDataMixed& _value) {
        _pd__initialised = _value._pd__initialised;
        switch(_value._pd__d) {
          case DataBoolean: booleanVal(_value._pd_booleanVal); break;

          case DataOctet: octetVal(_value._pd_octetVal); break;

          case DataLong: longVal(_value._pd_longVal); break;

          case DataDouble: doubleVal(_value._pd_doubleVal); break;

          case DataString: stringVal(_value._pd_stringVal); break;

          case DataPicture: picture(_value._pd_picture); break;

          case DataVector: vector(_value._pd_vector); break;

          case DataFile: file(_value._pd_file); break;

          case DataNone: outVal(_value._pd_outVal); break;

            default: break;

        
        }
        _pd__d = _value._pd__d;
    
        return *this;
      }

      TData _d() const { return _pd__d;}
      void _d(TData _value){
        // illegal to set discriminator before making a member active
        if (!_pd__initialised)
          OMNIORB_THROW(BAD_PARAM,_OMNI_NS(BAD_PARAM_InvalidUnionDiscValue),::CORBA::COMPLETED_NO);

        if (_value == _pd__d) return; // no change

        switch (_pd__d){
          case DataBoolean: goto fail;
          case DataOctet: goto fail;
          case DataLong: goto fail;
          case DataDouble: goto fail;
          case DataString: goto fail;
          case DataPicture: goto fail;
          case DataVector: goto fail;
          case DataFile: goto fail;
          case DataNone: goto fail;
          default: goto fail;

        };
        

        fail:
        OMNIORB_THROW(BAD_PARAM,_OMNI_NS(BAD_PARAM_InvalidUnionDiscValue),::CORBA::COMPLETED_NO);


    
      }

      

      ::CORBA::Boolean booleanVal () const { return _pd_booleanVal; }
      void booleanVal (::CORBA::Boolean  _value) {
        _pd__initialised = 1;
        _pd__d = DataBoolean;
        _pd__default = 0;
        _pd_booleanVal = _value;
      }

      ::CORBA::Octet octetVal () const { return _pd_octetVal; }
      void octetVal (::CORBA::Octet  _value) {
        _pd__initialised = 1;
        _pd__d = DataOctet;
        _pd__default = 0;
        _pd_octetVal = _value;
      }

      ::CORBA::Long longVal () const { return _pd_longVal; }
      void longVal (::CORBA::Long  _value) {
        _pd__initialised = 1;
        _pd__d = DataLong;
        _pd__default = 0;
        _pd_longVal = _value;
      }

      ::CORBA::Double doubleVal () const { return _pd_doubleVal; }
      void doubleVal (::CORBA::Double  _value) {
        _pd__initialised = 1;
        _pd__d = DataDouble;
        _pd__default = 0;
        _pd_doubleVal = _value;
      }

      const char * stringVal () const { return (const char*) _pd_stringVal; }
      void stringVal(char* _value) {
        _pd__initialised = 1;
        _pd__d = DataString;
        _pd__default = 0;
        _pd_stringVal = _value;
      }
      void stringVal(const char*  _value) {
        _pd__initialised = 1;
        _pd__d = DataString;
        _pd__default = 0;
        _pd_stringVal = _value;
      }
      void stringVal(const ::CORBA::String_var& _value) {
        _pd__initialised = 1;
        _pd__d = DataString;
        _pd__default = 0;
        _pd_stringVal = _value;
      }
      void stringVal(const ::CORBA::String_member& _value) {
        _pd__initialised = 1;
        _pd__d = DataString;
        _pd__default = 0;
        _pd_stringVal = _value;
      }

      const TPicture &picture () const { return _pd_picture; }
      TPicture &picture () { return _pd_picture; }
      void picture (const TPicture& _value) {
        _pd__initialised = 1;
        _pd__d = DataPicture;
        _pd__default = 0;
        _pd_picture = _value;
      }

      const TDataMixedSeq &vector () const { return _pd_vector; }
      TDataMixedSeq &vector () { return _pd_vector; }
      void vector (const TDataMixedSeq& _value) {
        _pd__initialised = 1;
        _pd__d = DataVector;
        _pd__default = 0;
        _pd_vector = _value;
      }

      const TFile &file () const { return _pd_file; }
      TFile &file () { return _pd_file; }
      void file (const TFile& _value) {
        _pd__initialised = 1;
        _pd__d = DataFile;
        _pd__default = 0;
        _pd_file = _value;
      }

      ::CORBA::Boolean outVal () const { return _pd_outVal; }
      void outVal (::CORBA::Boolean  _value) {
        _pd__initialised = 1;
        _pd__d = DataNone;
        _pd__default = 0;
        _pd_outVal = _value;
      }

    
      
      void operator>>= (cdrStream&) const;
      void operator<<= (cdrStream&);

    private:
      TData _pd__d;
      _CORBA_Boolean _pd__default;
      _CORBA_Boolean _pd__initialised;

      union {
        ::CORBA::Boolean _pd_booleanVal;

        ::CORBA::Octet _pd_octetVal;

        ::CORBA::Long _pd_longVal;


#ifndef USING_PROXY_FLOAT
          ::CORBA::Double _pd_doubleVal;
#endif

        ::CORBA::Boolean _pd_outVal;


      };

    
      
#ifdef USING_PROXY_FLOAT
        ::CORBA::Double _pd_doubleVal;
#endif

      ::CORBA::String_member _pd_stringVal;

      TPicture _pd_picture;

      TDataMixedSeq _pd_vector;

      TFile _pd_file;

    
    };

    typedef TDataMixed::_var_type TDataMixed_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< TDataMixed,TDataMixed_var > TDataMixed_out;

    class TVarMixed {
    public:

      typedef _CORBA_ConstrType_Variable_Var<TVarMixed> _var_type;

      

      TVarMixed(): _pd__initialised(0) {
        
      }
      
      TVarMixed(const TVarMixed& _value) {
        _pd__initialised = _value._pd__initialised;
        switch(_value._pd__d) {
          case TypeNumber: number(_value._pd_number); break;

          case TypeString: stringVal(_value._pd_stringVal); break;

          case TypeChannel: channel(_value._pd_channel); break;

          case TypeList: list(_value._pd_list); break;

          case TypeObject: objectVal(_value._pd_objectVal); break;

            default: break;

        
        }
        _pd__d = _value._pd__d;
    
      }

      ~TVarMixed() {}

      TVarMixed& operator=(const TVarMixed& _value) {
        _pd__initialised = _value._pd__initialised;
        switch(_value._pd__d) {
          case TypeNumber: number(_value._pd_number); break;

          case TypeString: stringVal(_value._pd_stringVal); break;

          case TypeChannel: channel(_value._pd_channel); break;

          case TypeList: list(_value._pd_list); break;

          case TypeObject: objectVal(_value._pd_objectVal); break;

            default: break;

        
        }
        _pd__d = _value._pd__d;
    
        return *this;
      }

      TType _d() const { return _pd__d;}
      void _d(TType _value){
        // illegal to set discriminator before making a member active
        if (!_pd__initialised)
          OMNIORB_THROW(BAD_PARAM,_OMNI_NS(BAD_PARAM_InvalidUnionDiscValue),::CORBA::COMPLETED_NO);

        if (_value == _pd__d) return; // no change

        switch (_pd__d){
          case TypeNumber: goto fail;
          case TypeString: goto fail;
          case TypeChannel: goto fail;
          case TypeList: goto fail;
          case TypeObject: goto fail;
          default: goto fail;

        };
        

        fail:
        OMNIORB_THROW(BAD_PARAM,_OMNI_NS(BAD_PARAM_InvalidUnionDiscValue),::CORBA::COMPLETED_NO);


    
      }

      

      ::CORBA::Double number () const { return _pd_number; }
      void number (::CORBA::Double  _value) {
        _pd__initialised = 1;
        _pd__d = TypeNumber;
        _pd__default = 0;
        _pd_number = _value;
      }

      const char * stringVal () const { return (const char*) _pd_stringVal; }
      void stringVal(char* _value) {
        _pd__initialised = 1;
        _pd__d = TypeString;
        _pd__default = 0;
        _pd_stringVal = _value;
      }
      void stringVal(const char*  _value) {
        _pd__initialised = 1;
        _pd__d = TypeString;
        _pd__default = 0;
        _pd_stringVal = _value;
      }
      void stringVal(const ::CORBA::String_var& _value) {
        _pd__initialised = 1;
        _pd__d = TypeString;
        _pd__default = 0;
        _pd_stringVal = _value;
      }
      void stringVal(const ::CORBA::String_member& _value) {
        _pd__initialised = 1;
        _pd__d = TypeString;
        _pd__default = 0;
        _pd_stringVal = _value;
      }

      ::CORBA::UShort channel () const { return _pd_channel; }
      void channel (::CORBA::UShort  _value) {
        _pd__initialised = 1;
        _pd__d = TypeChannel;
        _pd__default = 0;
        _pd_channel = _value;
      }

      const TVarMixedSeq &list () const { return _pd_list; }
      TVarMixedSeq &list () { return _pd_list; }
      void list (const TVarMixedSeq& _value) {
        _pd__initialised = 1;
        _pd__d = TypeList;
        _pd__default = 0;
        _pd_list = _value;
      }

      const char * objectVal () const { return (const char*) _pd_objectVal; }
      void objectVal(char* _value) {
        _pd__initialised = 1;
        _pd__d = TypeObject;
        _pd__default = 0;
        _pd_objectVal = _value;
      }
      void objectVal(const char*  _value) {
        _pd__initialised = 1;
        _pd__d = TypeObject;
        _pd__default = 0;
        _pd_objectVal = _value;
      }
      void objectVal(const ::CORBA::String_var& _value) {
        _pd__initialised = 1;
        _pd__d = TypeObject;
        _pd__default = 0;
        _pd_objectVal = _value;
      }
      void objectVal(const ::CORBA::String_member& _value) {
        _pd__initialised = 1;
        _pd__d = TypeObject;
        _pd__default = 0;
        _pd_objectVal = _value;
      }

    
      
      void operator>>= (cdrStream&) const;
      void operator<<= (cdrStream&);

    private:
      TType _pd__d;
      _CORBA_Boolean _pd__default;
      _CORBA_Boolean _pd__initialised;

      union {
        
#ifndef USING_PROXY_FLOAT
          ::CORBA::Double _pd_number;
#endif

        ::CORBA::UShort _pd_channel;


      };

    
      
#ifdef USING_PROXY_FLOAT
        ::CORBA::Double _pd_number;
#endif

      ::CORBA::String_member _pd_stringVal;

      TVarMixedSeq _pd_list;

      ::CORBA::String_member _pd_objectVal;

    
    };

    typedef TVarMixed::_var_type TVarMixed_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< TVarMixed,TVarMixed_var > TVarMixed_out;

    struct TAttribute {
      typedef _CORBA_ConstrType_Variable_Var<TAttribute> _var_type;

      
      ::CORBA::String_member key;

      ::CORBA::String_member value;

      TStringSeq values;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef TAttribute::_var_type TAttribute_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< TAttribute,TAttribute_var > TAttribute_out;

    struct TChannel {
      typedef _CORBA_ConstrType_Variable_Var<TChannel> _var_type;

      
      TDevice device;

      ::CORBA::UShort channel;

      TChannelType type;

      TData inputType;

      TValue outputType;

      ::CORBA::String_member channelName;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef TChannel::_var_type TChannel_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< TChannel,TChannel_var > TChannel_out;

    struct TDeviceChannel {
      typedef _CORBA_ConstrType_Variable_Var<TDeviceChannel> _var_type;

      
      ::CORBA::UShort channel;

      TChannelType type;

      TData inputType;

      TValue outputType;

      ::CORBA::String_member channelName;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef TDeviceChannel::_var_type TDeviceChannel_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< TDeviceChannel,TDeviceChannel_var > TDeviceChannel_out;

    struct TDeviceEvent {
      typedef _CORBA_ConstrType_Variable_Var<TDeviceEvent> _var_type;

      
      ::CORBA::UShort channel;

      ::CORBA::Double time;

      TValMixed value;

      TDevicePosition pos;

      ::CORBA::ULong eventNum;

      ::CORBA::Boolean isMeasurementEvent;

      ::CORBA::String_member description;

      ::CORBA::String_member channelName;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef TDeviceEvent::_var_type TDeviceEvent_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< TDeviceEvent,TDeviceEvent_var > TDeviceEvent_out;

    struct TEvent {
      typedef _CORBA_ConstrType_Variable_Var<TEvent> _var_type;

      
      ::CORBA::UShort channel;

      ::CORBA::Double time;

      TValMixed value;

      TPosition pos;

      ::CORBA::Boolean isMeasurementEvent;

      ::CORBA::String_member description;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef TEvent::_var_type TEvent_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< TEvent,TEvent_var > TEvent_out;

    struct TExpRunInfo {
      typedef _CORBA_ConstrType_Variable_Var<TExpRunInfo> _var_type;

      
      ::CORBA::String_member filename;

      ::CORBA::String_member description;

      ::CORBA::String_member serverBaseDirectory;

      ::CORBA::Boolean isSequenceMember;

      ::CORBA::String_member sequenceRelativePath;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef TExpRunInfo::_var_type TExpRunInfo_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< TExpRunInfo,TExpRunInfo_var > TExpRunInfo_out;

    struct TExpSequenceInfo {
      typedef _CORBA_ConstrType_Variable_Var<TExpSequenceInfo> _var_type;

      
      ::CORBA::String_member filename;

      ::CORBA::String_member sequenceDescription;

      ::CORBA::String_member serverBaseDirectory;

      ::CORBA::String_member trialFilenameBase;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef TExpSequenceInfo::_var_type TExpSequenceInfo_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< TExpSequenceInfo,TExpSequenceInfo_var > TExpSequenceInfo_out;

    struct TLabeledData {
      typedef _CORBA_ConstrType_Variable_Var<TLabeledData> _var_type;

      
      ::CORBA::String_member label;

      TDataMixed data;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef TLabeledData::_var_type TLabeledData_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< TLabeledData,TLabeledData_var > TLabeledData_out;

    struct TMeasurement {
      typedef _CORBA_ConstrType_Variable_Var<TMeasurement> _var_type;

      
      ::CORBA::UShort channel;

      ::CORBA::Double time;

      TDataMixed data;

      ::CORBA::String_member description;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef TMeasurement::_var_type TMeasurement_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< TMeasurement,TMeasurement_var > TMeasurement_out;

    struct TOverwritten {
      typedef _CORBA_ConstrType_Variable_Var<TOverwritten> _var_type;

      
      ::CORBA::String_member name;

      ::CORBA::String_member value;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef TOverwritten::_var_type TOverwritten_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< TOverwritten,TOverwritten_var > TOverwritten_out;

    struct TRow {
      typedef _CORBA_ConstrType_Variable_Var<TRow> _var_type;

      
      ::CORBA::ULong row;

      TStringSeq val;

      ::CORBA::Boolean done;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef TRow::_var_type TRow_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< TRow,TRow_var > TRow_out;

    struct TStatus {
      typedef _CORBA_ConstrType_Fix_Var<TStatus> _var_type;

      
      TStatusLevel level;

      ::CORBA::Double curTime;

      ::CORBA::ULong curEvent;

      ::CORBA::UShort curCycle;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef TStatus::_var_type TStatus_var;

    typedef TStatus& TStatus_out;

    struct TVariable {
      typedef _CORBA_ConstrType_Variable_Var<TVariable> _var_type;

      
      ::CORBA::String_member name;

      TVarMixed value;

      TPosition pos;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef TVariable::_var_type TVariable_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< TVariable,TVariable_var > TVariable_out;

  _CORBA_MODULE_END

_CORBA_MODULE_END



_CORBA_MODULE POA_STI
_CORBA_MODULE_BEG

  _CORBA_MODULE Types
  _CORBA_MODULE_BEG

    class TNetworkFile :
      public virtual STI::Types::_impl_TNetworkFile,
      public virtual ::PortableServer::ServantBase
    {
    public:
      virtual ~TNetworkFile();

      inline ::STI::Types::TNetworkFile_ptr _this() {
        return (::STI::Types::TNetworkFile_ptr) _do_this(::STI::Types::TNetworkFile::_PD_repoId);
      }
    };

  _CORBA_MODULE_END

_CORBA_MODULE_END



_CORBA_MODULE OBV_STI
_CORBA_MODULE_BEG

  _CORBA_MODULE Types
  _CORBA_MODULE_BEG

  _CORBA_MODULE_END

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

inline void operator >>=(STI::Types::TChannelType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (STI::Types::TChannelType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= STI::Types::Unknown) {
    _e = (STI::Types::TChannelType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

inline void operator >>=(STI::Types::TMessageType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (STI::Types::TMessageType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= STI::Types::DeviceError) {
    _e = (STI::Types::TMessageType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

inline void operator >>=(STI::Types::TStatusLevel _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (STI::Types::TStatusLevel& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= STI::Types::LevelUnparsed) {
    _e = (STI::Types::TStatusLevel) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

inline void operator >>=(STI::Types::TType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (STI::Types::TType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= STI::Types::TypeObject) {
    _e = (STI::Types::TType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

inline void operator >>=(STI::Types::DeviceStatus _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (STI::Types::DeviceStatus& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= STI::Types::Paused) {
    _e = (STI::Types::DeviceStatus) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

inline void operator >>=(STI::Types::TData _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (STI::Types::TData& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= STI::Types::DataNone) {
    _e = (STI::Types::TData) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

inline void operator >>=(STI::Types::TValue _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (STI::Types::TValue& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= STI::Types::ValueNone) {
    _e = (STI::Types::TValue) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}



inline void
STI::Types::TNetworkFile::_marshalObjRef(::STI::Types::TNetworkFile_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}




#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_orbTypes
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_orbTypes
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_orbTypes
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_orbTypes
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_orbTypes
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_orbTypes
#endif

#endif  // __orbTypes_hh__

