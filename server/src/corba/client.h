// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef __client_hh__
#define __client_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_client
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_client
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_client
#endif



#ifndef __orbTypes_hh_EXTERNAL_GUARD__
#define __orbTypes_hh_EXTERNAL_GUARD__
#include <orbTypes.h>
#endif



#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_MODULE STI

_CORBA_MODULE_BEG

  _CORBA_MODULE Client_Server

  _CORBA_MODULE_BEG

#ifndef __STI_mClient__Server_mModeInterrupt__
#define __STI_mClient__Server_mModeInterrupt__

    class ModeInterrupt;
    class _objref_ModeInterrupt;
    class _impl_ModeInterrupt;
    
    typedef _objref_ModeInterrupt* ModeInterrupt_ptr;
    typedef ModeInterrupt_ptr ModeInterruptRef;

    class ModeInterrupt_Helper {
    public:
      typedef ModeInterrupt_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_ModeInterrupt, ModeInterrupt_Helper> ModeInterrupt_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_ModeInterrupt,ModeInterrupt_Helper > ModeInterrupt_out;

#endif

    // interface ModeInterrupt
    class ModeInterrupt {
    public:
      // Declarations for this interface type.
      typedef ModeInterrupt_ptr _ptr_type;
      typedef ModeInterrupt_var _var_type;

      static _ptr_type _duplicate(_ptr_type);
      static _ptr_type _narrow(::CORBA::Object_ptr);
      static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
      
      static _ptr_type _nil();

      static inline void _marshalObjRef(_ptr_type, cdrStream&);

      static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
        omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static _core_attr const char* _PD_repoId;

      // Other IDL defined within this scope.
      
    };

    class _objref_ModeInterrupt :
      public virtual ::CORBA::Object,
      public virtual omniObjRef
    {
    public:
      void requestControl(const char* myName, const char* ipAddress);
      void controlTakenBy(const char* myName, const char* ipAddress);

      inline _objref_ModeInterrupt()  { _PR_setobj(0); }  // nil
      _objref_ModeInterrupt(omniIOR*, omniIdentity*);

    protected:
      virtual ~_objref_ModeInterrupt();

      
    private:
      virtual void* _ptrToObjRef(const char*);

      _objref_ModeInterrupt(const _objref_ModeInterrupt&);
      _objref_ModeInterrupt& operator = (const _objref_ModeInterrupt&);
      // not implemented

      friend class ModeInterrupt;
    };

    class _pof_ModeInterrupt : public _OMNI_NS(proxyObjectFactory) {
    public:
      inline _pof_ModeInterrupt() : _OMNI_NS(proxyObjectFactory)(ModeInterrupt::_PD_repoId) {}
      virtual ~_pof_ModeInterrupt();

      virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
      virtual _CORBA_Boolean is_a(const char*) const;
    };

    class _impl_ModeInterrupt :
      public virtual omniServant
    {
    public:
      virtual ~_impl_ModeInterrupt();

      virtual void requestControl(const char* myName, const char* ipAddress) = 0;
      virtual void controlTakenBy(const char* myName, const char* ipAddress) = 0;
      
    public:  // Really protected, workaround for xlC
      virtual _CORBA_Boolean _dispatch(omniCallHandle&);

    private:
      virtual void* _ptrToInterface(const char*);
      virtual const char* _mostDerivedRepoId();
      
    };


#ifndef __STI_mClient__Server_mModeHandler__
#define __STI_mClient__Server_mModeHandler__

    class ModeHandler;
    class _objref_ModeHandler;
    class _impl_ModeHandler;
    
    typedef _objref_ModeHandler* ModeHandler_ptr;
    typedef ModeHandler_ptr ModeHandlerRef;

    class ModeHandler_Helper {
    public:
      typedef ModeHandler_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_ModeHandler, ModeHandler_Helper> ModeHandler_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_ModeHandler,ModeHandler_Helper > ModeHandler_out;

#endif

    // interface ModeHandler
    class ModeHandler {
    public:
      // Declarations for this interface type.
      typedef ModeHandler_ptr _ptr_type;
      typedef ModeHandler_var _var_type;

      static _ptr_type _duplicate(_ptr_type);
      static _ptr_type _narrow(::CORBA::Object_ptr);
      static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
      
      static _ptr_type _nil();

      static inline void _marshalObjRef(_ptr_type, cdrStream&);

      static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
        omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static _core_attr const char* _PD_repoId;

      // Other IDL defined within this scope.
      
    };

    class _objref_ModeHandler :
      public virtual ::CORBA::Object,
      public virtual omniObjRef
    {
    public:
      ::CORBA::Boolean requestControl(const char* myName, const char* ipAddress, ModeInterrupt_ptr interrupt);
      ::CORBA::Boolean takeControl(const char* myName, const char* ipAddress, ModeInterrupt_ptr interrupt);
      void cancelRequest();
      void answerRequest(::CORBA::Boolean yield);
      char* controllerName();
      char* controllerIP();

      inline _objref_ModeHandler()  { _PR_setobj(0); }  // nil
      _objref_ModeHandler(omniIOR*, omniIdentity*);

    protected:
      virtual ~_objref_ModeHandler();

      
    private:
      virtual void* _ptrToObjRef(const char*);

      _objref_ModeHandler(const _objref_ModeHandler&);
      _objref_ModeHandler& operator = (const _objref_ModeHandler&);
      // not implemented

      friend class ModeHandler;
    };

    class _pof_ModeHandler : public _OMNI_NS(proxyObjectFactory) {
    public:
      inline _pof_ModeHandler() : _OMNI_NS(proxyObjectFactory)(ModeHandler::_PD_repoId) {}
      virtual ~_pof_ModeHandler();

      virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
      virtual _CORBA_Boolean is_a(const char*) const;
    };

    class _impl_ModeHandler :
      public virtual omniServant
    {
    public:
      virtual ~_impl_ModeHandler();

      virtual ::CORBA::Boolean requestControl(const char* myName, const char* ipAddress, ModeInterrupt_ptr interrupt) = 0;
      virtual ::CORBA::Boolean takeControl(const char* myName, const char* ipAddress, ModeInterrupt_ptr interrupt) = 0;
      virtual void cancelRequest() = 0;
      virtual void answerRequest(::CORBA::Boolean yield) = 0;
      virtual char* controllerName() = 0;
      virtual char* controllerIP() = 0;
      
    public:  // Really protected, workaround for xlC
      virtual _CORBA_Boolean _dispatch(omniCallHandle&);

    private:
      virtual void* _ptrToInterface(const char*);
      virtual const char* _mostDerivedRepoId();
      
    };


#ifndef __STI_mClient__Server_mMessenger__
#define __STI_mClient__Server_mMessenger__

    class Messenger;
    class _objref_Messenger;
    class _impl_Messenger;
    
    typedef _objref_Messenger* Messenger_ptr;
    typedef Messenger_ptr MessengerRef;

    class Messenger_Helper {
    public:
      typedef Messenger_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_Messenger, Messenger_Helper> Messenger_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_Messenger,Messenger_Helper > Messenger_out;

#endif

    // interface Messenger
    class Messenger {
    public:
      // Declarations for this interface type.
      typedef Messenger_ptr _ptr_type;
      typedef Messenger_var _var_type;

      static _ptr_type _duplicate(_ptr_type);
      static _ptr_type _narrow(::CORBA::Object_ptr);
      static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
      
      static _ptr_type _nil();

      static inline void _marshalObjRef(_ptr_type, cdrStream&);

      static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
        omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static _core_attr const char* _PD_repoId;

      // Other IDL defined within this scope.
      
    };

    class _objref_Messenger :
      public virtual ::CORBA::Object,
      public virtual omniObjRef
    {
    public:
      void sendMessage(const char* message);

      inline _objref_Messenger()  { _PR_setobj(0); }  // nil
      _objref_Messenger(omniIOR*, omniIdentity*);

    protected:
      virtual ~_objref_Messenger();

      
    private:
      virtual void* _ptrToObjRef(const char*);

      _objref_Messenger(const _objref_Messenger&);
      _objref_Messenger& operator = (const _objref_Messenger&);
      // not implemented

      friend class Messenger;
    };

    class _pof_Messenger : public _OMNI_NS(proxyObjectFactory) {
    public:
      inline _pof_Messenger() : _OMNI_NS(proxyObjectFactory)(Messenger::_PD_repoId) {}
      virtual ~_pof_Messenger();

      virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
      virtual _CORBA_Boolean is_a(const char*) const;
    };

    class _impl_Messenger :
      public virtual omniServant
    {
    public:
      virtual ~_impl_Messenger();

      virtual void sendMessage(const char* message) = 0;
      
    public:  // Really protected, workaround for xlC
      virtual _CORBA_Boolean _dispatch(omniCallHandle&);

    private:
      virtual void* _ptrToInterface(const char*);
      virtual const char* _mostDerivedRepoId();
      
    };


#ifndef __STI_mClient__Server_mClientRefresher__
#define __STI_mClient__Server_mClientRefresher__

    class ClientRefresher;
    class _objref_ClientRefresher;
    class _impl_ClientRefresher;
    
    typedef _objref_ClientRefresher* ClientRefresher_ptr;
    typedef ClientRefresher_ptr ClientRefresherRef;

    class ClientRefresher_Helper {
    public:
      typedef ClientRefresher_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_ClientRefresher, ClientRefresher_Helper> ClientRefresher_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_ClientRefresher,ClientRefresher_Helper > ClientRefresher_out;

#endif

    // interface ClientRefresher
    class ClientRefresher {
    public:
      // Declarations for this interface type.
      typedef ClientRefresher_ptr _ptr_type;
      typedef ClientRefresher_var _var_type;

      static _ptr_type _duplicate(_ptr_type);
      static _ptr_type _narrow(::CORBA::Object_ptr);
      static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
      
      static _ptr_type _nil();

      static inline void _marshalObjRef(_ptr_type, cdrStream&);

      static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
        omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static _core_attr const char* _PD_repoId;

      // Other IDL defined within this scope.
      
    };

    class _objref_ClientRefresher :
      public virtual ::CORBA::Object,
      public virtual omniObjRef
    {
    public:
      void reportDeviceMessage(const char* deviceID, Types::TMessageType type, const char* message);
      void forceDeviceAttributeRefresh(const char* deviceID);

      inline _objref_ClientRefresher()  { _PR_setobj(0); }  // nil
      _objref_ClientRefresher(omniIOR*, omniIdentity*);

    protected:
      virtual ~_objref_ClientRefresher();

      
    private:
      virtual void* _ptrToObjRef(const char*);

      _objref_ClientRefresher(const _objref_ClientRefresher&);
      _objref_ClientRefresher& operator = (const _objref_ClientRefresher&);
      // not implemented

      friend class ClientRefresher;
    };

    class _pof_ClientRefresher : public _OMNI_NS(proxyObjectFactory) {
    public:
      inline _pof_ClientRefresher() : _OMNI_NS(proxyObjectFactory)(ClientRefresher::_PD_repoId) {}
      virtual ~_pof_ClientRefresher();

      virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
      virtual _CORBA_Boolean is_a(const char*) const;
    };

    class _impl_ClientRefresher :
      public virtual omniServant
    {
    public:
      virtual ~_impl_ClientRefresher();

      virtual void reportDeviceMessage(const char* deviceID, Types::TMessageType type, const char* message) = 0;
      virtual void forceDeviceAttributeRefresh(const char* deviceID) = 0;
      
    public:  // Really protected, workaround for xlC
      virtual _CORBA_Boolean _dispatch(omniCallHandle&);

    private:
      virtual void* _ptrToInterface(const char*);
      virtual const char* _mostDerivedRepoId();
      
    };


#ifndef __STI_mClient__Server_mServerPinger__
#define __STI_mClient__Server_mServerPinger__

    class ServerPinger;
    class _objref_ServerPinger;
    class _impl_ServerPinger;
    
    typedef _objref_ServerPinger* ServerPinger_ptr;
    typedef ServerPinger_ptr ServerPingerRef;

    class ServerPinger_Helper {
    public:
      typedef ServerPinger_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_ServerPinger, ServerPinger_Helper> ServerPinger_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_ServerPinger,ServerPinger_Helper > ServerPinger_out;

#endif

    // interface ServerPinger
    class ServerPinger {
    public:
      // Declarations for this interface type.
      typedef ServerPinger_ptr _ptr_type;
      typedef ServerPinger_var _var_type;

      static _ptr_type _duplicate(_ptr_type);
      static _ptr_type _narrow(::CORBA::Object_ptr);
      static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
      
      static _ptr_type _nil();

      static inline void _marshalObjRef(_ptr_type, cdrStream&);

      static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
        omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static _core_attr const char* _PD_repoId;

      // Other IDL defined within this scope.
      
    };

    class _objref_ServerPinger :
      public virtual ::CORBA::Object,
      public virtual omniObjRef
    {
    public:
      void pingServer(ClientRefresher_ptr refresher);

      inline _objref_ServerPinger()  { _PR_setobj(0); }  // nil
      _objref_ServerPinger(omniIOR*, omniIdentity*);

    protected:
      virtual ~_objref_ServerPinger();

      
    private:
      virtual void* _ptrToObjRef(const char*);

      _objref_ServerPinger(const _objref_ServerPinger&);
      _objref_ServerPinger& operator = (const _objref_ServerPinger&);
      // not implemented

      friend class ServerPinger;
    };

    class _pof_ServerPinger : public _OMNI_NS(proxyObjectFactory) {
    public:
      inline _pof_ServerPinger() : _OMNI_NS(proxyObjectFactory)(ServerPinger::_PD_repoId) {}
      virtual ~_pof_ServerPinger();

      virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
      virtual _CORBA_Boolean is_a(const char*) const;
    };

    class _impl_ServerPinger :
      public virtual omniServant
    {
    public:
      virtual ~_impl_ServerPinger();

      virtual void pingServer(ClientRefresher_ptr refresher) = 0;
      
    public:  // Really protected, workaround for xlC
      virtual _CORBA_Boolean _dispatch(omniCallHandle&);

    private:
      virtual void* _ptrToInterface(const char*);
      virtual const char* _mostDerivedRepoId();
      
    };


#ifndef __STI_mClient__Server_mParser__
#define __STI_mClient__Server_mParser__

    class Parser;
    class _objref_Parser;
    class _impl_Parser;
    
    typedef _objref_Parser* Parser_ptr;
    typedef Parser_ptr ParserRef;

    class Parser_Helper {
    public:
      typedef Parser_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_Parser, Parser_Helper> Parser_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_Parser,Parser_Helper > Parser_out;

#endif

    // interface Parser
    class Parser {
    public:
      // Declarations for this interface type.
      typedef Parser_ptr _ptr_type;
      typedef Parser_var _var_type;

      static _ptr_type _duplicate(_ptr_type);
      static _ptr_type _narrow(::CORBA::Object_ptr);
      static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
      
      static _ptr_type _nil();

      static inline void _marshalObjRef(_ptr_type, cdrStream&);

      static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
        omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static _core_attr const char* _PD_repoId;

      // Other IDL defined within this scope.
      
    };

    class _objref_Parser :
      public virtual ::CORBA::Object,
      public virtual omniObjRef
    {
    public:
      ::CORBA::Boolean parseFile(const char* filename, Messenger_ptr parserCallback);
      ::CORBA::Boolean parseString(const char* code);
      ::CORBA::Boolean parseLoopScript(const char* script);
      Types::TOverwrittenSeq* overwritten();
      void overwritten(const Types::TOverwrittenSeq& _v);
      ::CORBA::Boolean lockOnParse();
      void lockOnParse(::CORBA::Boolean _v);
      char* outMsg();
      char* errMsg();
      char* mainFile();
      Types::TChannelSeq* channels();
      Types::TStringSeq* files();
      Types::TVariableSeq* variables();
      Types::TEventSeq* events();

      inline _objref_Parser()  { _PR_setobj(0); }  // nil
      _objref_Parser(omniIOR*, omniIdentity*);

    protected:
      virtual ~_objref_Parser();

      
    private:
      virtual void* _ptrToObjRef(const char*);

      _objref_Parser(const _objref_Parser&);
      _objref_Parser& operator = (const _objref_Parser&);
      // not implemented

      friend class Parser;
    };

    class _pof_Parser : public _OMNI_NS(proxyObjectFactory) {
    public:
      inline _pof_Parser() : _OMNI_NS(proxyObjectFactory)(Parser::_PD_repoId) {}
      virtual ~_pof_Parser();

      virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
      virtual _CORBA_Boolean is_a(const char*) const;
    };

    class _impl_Parser :
      public virtual omniServant
    {
    public:
      virtual ~_impl_Parser();

      virtual ::CORBA::Boolean parseFile(const char* filename, Messenger_ptr parserCallback) = 0;
      virtual ::CORBA::Boolean parseString(const char* code) = 0;
      virtual ::CORBA::Boolean parseLoopScript(const char* script) = 0;
      virtual Types::TOverwrittenSeq* overwritten() = 0;
      virtual void overwritten(const Types::TOverwrittenSeq& _v) = 0;
      virtual ::CORBA::Boolean lockOnParse() = 0;
      virtual void lockOnParse(::CORBA::Boolean _v) = 0;
      virtual char* outMsg() = 0;
      virtual char* errMsg() = 0;
      virtual char* mainFile() = 0;
      virtual Types::TChannelSeq* channels() = 0;
      virtual Types::TStringSeq* files() = 0;
      virtual Types::TVariableSeq* variables() = 0;
      virtual Types::TEventSeq* events() = 0;
      
    public:  // Really protected, workaround for xlC
      virtual _CORBA_Boolean _dispatch(omniCallHandle&);

    private:
      virtual void* _ptrToInterface(const char*);
      virtual const char* _mostDerivedRepoId();
      
    };


#ifndef __STI_mClient__Server_mExpSequence__
#define __STI_mClient__Server_mExpSequence__

    class ExpSequence;
    class _objref_ExpSequence;
    class _impl_ExpSequence;
    
    typedef _objref_ExpSequence* ExpSequence_ptr;
    typedef ExpSequence_ptr ExpSequenceRef;

    class ExpSequence_Helper {
    public:
      typedef ExpSequence_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_ExpSequence, ExpSequence_Helper> ExpSequence_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_ExpSequence,ExpSequence_Helper > ExpSequence_out;

#endif

    // interface ExpSequence
    class ExpSequence {
    public:
      // Declarations for this interface type.
      typedef ExpSequence_ptr _ptr_type;
      typedef ExpSequence_var _var_type;

      static _ptr_type _duplicate(_ptr_type);
      static _ptr_type _narrow(::CORBA::Object_ptr);
      static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
      
      static _ptr_type _nil();

      static inline void _marshalObjRef(_ptr_type, cdrStream&);

      static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
        omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static _core_attr const char* _PD_repoId;

      // Other IDL defined within this scope.
      
    };

    class _objref_ExpSequence :
      public virtual ::CORBA::Object,
      public virtual omniObjRef
    {
    public:
      ::CORBA::Boolean setExpSequence(const Types::TStringSeq& Variables, const Types::TRowSeq& Experiments);
      ::CORBA::Boolean appendRow(const Types::TStringSeq& newRow);
      ::CORBA::Boolean moveRow(::CORBA::ULong oldPos, ::CORBA::ULong newPos);
      ::CORBA::Boolean editRow(::CORBA::ULong pos, const Types::TRow& newRow);
      ::CORBA::Boolean deleteRow(::CORBA::ULong pos);
      void clear();
      ::CORBA::Boolean editRowDone(::CORBA::ULong pos, ::CORBA::Boolean newDone);
      Types::TStringSeq* variables();
      void variables(const Types::TStringSeq& _v);
      Types::TRowSeq* experiments();

      inline _objref_ExpSequence()  { _PR_setobj(0); }  // nil
      _objref_ExpSequence(omniIOR*, omniIdentity*);

    protected:
      virtual ~_objref_ExpSequence();

      
    private:
      virtual void* _ptrToObjRef(const char*);

      _objref_ExpSequence(const _objref_ExpSequence&);
      _objref_ExpSequence& operator = (const _objref_ExpSequence&);
      // not implemented

      friend class ExpSequence;
    };

    class _pof_ExpSequence : public _OMNI_NS(proxyObjectFactory) {
    public:
      inline _pof_ExpSequence() : _OMNI_NS(proxyObjectFactory)(ExpSequence::_PD_repoId) {}
      virtual ~_pof_ExpSequence();

      virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
      virtual _CORBA_Boolean is_a(const char*) const;
    };

    class _impl_ExpSequence :
      public virtual omniServant
    {
    public:
      virtual ~_impl_ExpSequence();

      virtual ::CORBA::Boolean setExpSequence(const Types::TStringSeq& Variables, const Types::TRowSeq& Experiments) = 0;
      virtual ::CORBA::Boolean appendRow(const Types::TStringSeq& newRow) = 0;
      virtual ::CORBA::Boolean moveRow(::CORBA::ULong oldPos, ::CORBA::ULong newPos) = 0;
      virtual ::CORBA::Boolean editRow(::CORBA::ULong pos, const Types::TRow& newRow) = 0;
      virtual ::CORBA::Boolean deleteRow(::CORBA::ULong pos) = 0;
      virtual void clear() = 0;
      virtual ::CORBA::Boolean editRowDone(::CORBA::ULong pos, ::CORBA::Boolean newDone) = 0;
      virtual Types::TStringSeq* variables() = 0;
      virtual void variables(const Types::TStringSeq& _v) = 0;
      virtual Types::TRowSeq* experiments() = 0;
      
    public:  // Really protected, workaround for xlC
      virtual _CORBA_Boolean _dispatch(omniCallHandle&);

    private:
      virtual void* _ptrToInterface(const char*);
      virtual const char* _mostDerivedRepoId();
      
    };


#ifndef __STI_mClient__Server_mControl__
#define __STI_mClient__Server_mControl__

    class Control;
    class _objref_Control;
    class _impl_Control;
    
    typedef _objref_Control* Control_ptr;
    typedef Control_ptr ControlRef;

    class Control_Helper {
    public:
      typedef Control_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_Control, Control_Helper> Control_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_Control,Control_Helper > Control_out;

#endif

    // interface Control
    class Control {
    public:
      // Declarations for this interface type.
      typedef Control_ptr _ptr_type;
      typedef Control_var _var_type;

      static _ptr_type _duplicate(_ptr_type);
      static _ptr_type _narrow(::CORBA::Object_ptr);
      static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
      
      static _ptr_type _nil();

      static inline void _marshalObjRef(_ptr_type, cdrStream&);

      static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
        omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static _core_attr const char* _PD_repoId;

      // Other IDL defined within this scope.
      
    };

    class _objref_Control :
      public virtual ::CORBA::Object,
      public virtual omniObjRef
    {
    public:
      Types::TStatus status();
      char* transferErr(const char* deviceID);
      void reset();
      void setDirect();
      void runSingle(::CORBA::Boolean documented);
      void runSequence(::CORBA::Boolean documented);
      void runSingleContinuous();
      void _cxx_continue();
      void pause();
      void resume();
      void stop();
      Types::TExpRunInfo* getDefaultRunInfo();
      Types::TExpSequenceInfo* getDefaultSequenceInfo();
      char* errMsg();

      inline _objref_Control()  { _PR_setobj(0); }  // nil
      _objref_Control(omniIOR*, omniIdentity*);

    protected:
      virtual ~_objref_Control();

      
    private:
      virtual void* _ptrToObjRef(const char*);

      _objref_Control(const _objref_Control&);
      _objref_Control& operator = (const _objref_Control&);
      // not implemented

      friend class Control;
    };

    class _pof_Control : public _OMNI_NS(proxyObjectFactory) {
    public:
      inline _pof_Control() : _OMNI_NS(proxyObjectFactory)(Control::_PD_repoId) {}
      virtual ~_pof_Control();

      virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
      virtual _CORBA_Boolean is_a(const char*) const;
    };

    class _impl_Control :
      public virtual omniServant
    {
    public:
      virtual ~_impl_Control();

      virtual Types::TStatus status() = 0;
      virtual char* transferErr(const char* deviceID) = 0;
      virtual void reset() = 0;
      virtual void setDirect() = 0;
      virtual void runSingle(::CORBA::Boolean documented) = 0;
      virtual void runSequence(::CORBA::Boolean documented) = 0;
      virtual void runSingleContinuous() = 0;
      virtual void _cxx_continue() = 0;
      virtual void pause() = 0;
      virtual void resume() = 0;
      virtual void stop() = 0;
      virtual Types::TExpRunInfo* getDefaultRunInfo() = 0;
      virtual Types::TExpSequenceInfo* getDefaultSequenceInfo() = 0;
      virtual char* errMsg() = 0;
      
    public:  // Really protected, workaround for xlC
      virtual _CORBA_Boolean _dispatch(omniCallHandle&);

    private:
      virtual void* _ptrToInterface(const char*);
      virtual const char* _mostDerivedRepoId();
      
    };


#ifndef __STI_mClient__Server_mDocumentationSettings__
#define __STI_mClient__Server_mDocumentationSettings__

    class DocumentationSettings;
    class _objref_DocumentationSettings;
    class _impl_DocumentationSettings;
    
    typedef _objref_DocumentationSettings* DocumentationSettings_ptr;
    typedef DocumentationSettings_ptr DocumentationSettingsRef;

    class DocumentationSettings_Helper {
    public:
      typedef DocumentationSettings_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_DocumentationSettings, DocumentationSettings_Helper> DocumentationSettings_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_DocumentationSettings,DocumentationSettings_Helper > DocumentationSettings_out;

#endif

    // interface DocumentationSettings
    class DocumentationSettings {
    public:
      // Declarations for this interface type.
      typedef DocumentationSettings_ptr _ptr_type;
      typedef DocumentationSettings_var _var_type;

      static _ptr_type _duplicate(_ptr_type);
      static _ptr_type _narrow(::CORBA::Object_ptr);
      static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
      
      static _ptr_type _nil();

      static inline void _marshalObjRef(_ptr_type, cdrStream&);

      static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
        omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static _core_attr const char* _PD_repoId;

      // Other IDL defined within this scope.
      
    };

    class _objref_DocumentationSettings :
      public virtual ::CORBA::Object,
      public virtual omniObjRef
    {
    public:
      char* DocumentationBaseAbsDir();
      void DocumentationBaseAbsDir(const char* _v);
      char* DTDFileAbsDir();
      void DTDFileAbsDir(const char* _v);
      char* TimingFilesRelDir();
      void TimingFilesRelDir(const char* _v);
      char* DataFilesRelDir();
      void DataFilesRelDir(const char* _v);
      char* ExperimentFilesRelDir();
      void ExperimentFilesRelDir(const char* _v);
      char* SequenceFilesRelDir();
      void SequenceFilesRelDir(const char* _v);

      inline _objref_DocumentationSettings()  { _PR_setobj(0); }  // nil
      _objref_DocumentationSettings(omniIOR*, omniIdentity*);

    protected:
      virtual ~_objref_DocumentationSettings();

      
    private:
      virtual void* _ptrToObjRef(const char*);

      _objref_DocumentationSettings(const _objref_DocumentationSettings&);
      _objref_DocumentationSettings& operator = (const _objref_DocumentationSettings&);
      // not implemented

      friend class DocumentationSettings;
    };

    class _pof_DocumentationSettings : public _OMNI_NS(proxyObjectFactory) {
    public:
      inline _pof_DocumentationSettings() : _OMNI_NS(proxyObjectFactory)(DocumentationSettings::_PD_repoId) {}
      virtual ~_pof_DocumentationSettings();

      virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
      virtual _CORBA_Boolean is_a(const char*) const;
    };

    class _impl_DocumentationSettings :
      public virtual omniServant
    {
    public:
      virtual ~_impl_DocumentationSettings();

      virtual char* DocumentationBaseAbsDir() = 0;
      virtual void DocumentationBaseAbsDir(const char* _v) = 0;
      virtual char* DTDFileAbsDir() = 0;
      virtual void DTDFileAbsDir(const char* _v) = 0;
      virtual char* TimingFilesRelDir() = 0;
      virtual void TimingFilesRelDir(const char* _v) = 0;
      virtual char* DataFilesRelDir() = 0;
      virtual void DataFilesRelDir(const char* _v) = 0;
      virtual char* ExperimentFilesRelDir() = 0;
      virtual void ExperimentFilesRelDir(const char* _v) = 0;
      virtual char* SequenceFilesRelDir() = 0;
      virtual void SequenceFilesRelDir(const char* _v) = 0;
      
    public:  // Really protected, workaround for xlC
      virtual _CORBA_Boolean _dispatch(omniCallHandle&);

    private:
      virtual void* _ptrToInterface(const char*);
      virtual const char* _mostDerivedRepoId();
      
    };


#ifndef __STI_mClient__Server_mDeviceConfigure__
#define __STI_mClient__Server_mDeviceConfigure__

    class DeviceConfigure;
    class _objref_DeviceConfigure;
    class _impl_DeviceConfigure;
    
    typedef _objref_DeviceConfigure* DeviceConfigure_ptr;
    typedef DeviceConfigure_ptr DeviceConfigureRef;

    class DeviceConfigure_Helper {
    public:
      typedef DeviceConfigure_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_DeviceConfigure, DeviceConfigure_Helper> DeviceConfigure_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_DeviceConfigure,DeviceConfigure_Helper > DeviceConfigure_out;

#endif

    // interface DeviceConfigure
    class DeviceConfigure {
    public:
      // Declarations for this interface type.
      typedef DeviceConfigure_ptr _ptr_type;
      typedef DeviceConfigure_var _var_type;

      static _ptr_type _duplicate(_ptr_type);
      static _ptr_type _narrow(::CORBA::Object_ptr);
      static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
      
      static _ptr_type _nil();

      static inline void _marshalObjRef(_ptr_type, cdrStream&);

      static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
        omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static _core_attr const char* _PD_repoId;

      // Other IDL defined within this scope.
      
    };

    class _objref_DeviceConfigure :
      public virtual ::CORBA::Object,
      public virtual omniObjRef
    {
    public:
      Types::TAttributeSeq* getDeviceAttributes(const char* deviceID);
      ::CORBA::Boolean setDeviceAttribute(const char* deviceID, const char* key, const char* value);
      Types::TChannelSeq* getDeviceChannels(const char* deviceID);
      ::CORBA::Boolean deviceStatus(const char* deviceID);
      ::CORBA::Long devicePing(const char* deviceID);
      void killDevice(const char* deviceID);
      Types::TDeviceSeq* devices();

      inline _objref_DeviceConfigure()  { _PR_setobj(0); }  // nil
      _objref_DeviceConfigure(omniIOR*, omniIdentity*);

    protected:
      virtual ~_objref_DeviceConfigure();

      
    private:
      virtual void* _ptrToObjRef(const char*);

      _objref_DeviceConfigure(const _objref_DeviceConfigure&);
      _objref_DeviceConfigure& operator = (const _objref_DeviceConfigure&);
      // not implemented

      friend class DeviceConfigure;
    };

    class _pof_DeviceConfigure : public _OMNI_NS(proxyObjectFactory) {
    public:
      inline _pof_DeviceConfigure() : _OMNI_NS(proxyObjectFactory)(DeviceConfigure::_PD_repoId) {}
      virtual ~_pof_DeviceConfigure();

      virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
      virtual _CORBA_Boolean is_a(const char*) const;
    };

    class _impl_DeviceConfigure :
      public virtual omniServant
    {
    public:
      virtual ~_impl_DeviceConfigure();

      virtual Types::TAttributeSeq* getDeviceAttributes(const char* deviceID) = 0;
      virtual ::CORBA::Boolean setDeviceAttribute(const char* deviceID, const char* key, const char* value) = 0;
      virtual Types::TChannelSeq* getDeviceChannels(const char* deviceID) = 0;
      virtual ::CORBA::Boolean deviceStatus(const char* deviceID) = 0;
      virtual ::CORBA::Long devicePing(const char* deviceID) = 0;
      virtual void killDevice(const char* deviceID) = 0;
      virtual Types::TDeviceSeq* devices() = 0;
      
    public:  // Really protected, workaround for xlC
      virtual _CORBA_Boolean _dispatch(omniCallHandle&);

    private:
      virtual void* _ptrToInterface(const char*);
      virtual const char* _mostDerivedRepoId();
      
    };


#ifndef __STI_mClient__Server_mStreamingDataTransfer__
#define __STI_mClient__Server_mStreamingDataTransfer__

    class StreamingDataTransfer;
    class _objref_StreamingDataTransfer;
    class _impl_StreamingDataTransfer;
    
    typedef _objref_StreamingDataTransfer* StreamingDataTransfer_ptr;
    typedef StreamingDataTransfer_ptr StreamingDataTransferRef;

    class StreamingDataTransfer_Helper {
    public:
      typedef StreamingDataTransfer_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_StreamingDataTransfer, StreamingDataTransfer_Helper> StreamingDataTransfer_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_StreamingDataTransfer,StreamingDataTransfer_Helper > StreamingDataTransfer_out;

#endif

    // interface StreamingDataTransfer
    class StreamingDataTransfer {
    public:
      // Declarations for this interface type.
      typedef StreamingDataTransfer_ptr _ptr_type;
      typedef StreamingDataTransfer_var _var_type;

      static _ptr_type _duplicate(_ptr_type);
      static _ptr_type _narrow(::CORBA::Object_ptr);
      static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
      
      static _ptr_type _nil();

      static inline void _marshalObjRef(_ptr_type, cdrStream&);

      static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
        omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static _core_attr const char* _PD_repoId;

      // Other IDL defined within this scope.
      
    };

    class _objref_StreamingDataTransfer :
      public virtual ::CORBA::Object,
      public virtual omniObjRef
    {
    public:
      Types::TMeasurementSeq* getStreamingData(const char* deviceID, ::CORBA::UShort channel, ::CORBA::Double initial_t, ::CORBA::Double final_t, ::CORBA::Double delta_t);
      Types::TMeasurementSeq* getMeasurements(const char* deviceID);
      char* getErrMsg(const char* deviceID);

      inline _objref_StreamingDataTransfer()  { _PR_setobj(0); }  // nil
      _objref_StreamingDataTransfer(omniIOR*, omniIdentity*);

    protected:
      virtual ~_objref_StreamingDataTransfer();

      
    private:
      virtual void* _ptrToObjRef(const char*);

      _objref_StreamingDataTransfer(const _objref_StreamingDataTransfer&);
      _objref_StreamingDataTransfer& operator = (const _objref_StreamingDataTransfer&);
      // not implemented

      friend class StreamingDataTransfer;
    };

    class _pof_StreamingDataTransfer : public _OMNI_NS(proxyObjectFactory) {
    public:
      inline _pof_StreamingDataTransfer() : _OMNI_NS(proxyObjectFactory)(StreamingDataTransfer::_PD_repoId) {}
      virtual ~_pof_StreamingDataTransfer();

      virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
      virtual _CORBA_Boolean is_a(const char*) const;
    };

    class _impl_StreamingDataTransfer :
      public virtual omniServant
    {
    public:
      virtual ~_impl_StreamingDataTransfer();

      virtual Types::TMeasurementSeq* getStreamingData(const char* deviceID, ::CORBA::UShort channel, ::CORBA::Double initial_t, ::CORBA::Double final_t, ::CORBA::Double delta_t) = 0;
      virtual Types::TMeasurementSeq* getMeasurements(const char* deviceID) = 0;
      virtual char* getErrMsg(const char* deviceID) = 0;
      
    public:  // Really protected, workaround for xlC
      virtual _CORBA_Boolean _dispatch(omniCallHandle&);

    private:
      virtual void* _ptrToInterface(const char*);
      virtual const char* _mostDerivedRepoId();
      
    };


#ifndef __STI_mClient__Server_mServerCommandLine__
#define __STI_mClient__Server_mServerCommandLine__

    class ServerCommandLine;
    class _objref_ServerCommandLine;
    class _impl_ServerCommandLine;
    
    typedef _objref_ServerCommandLine* ServerCommandLine_ptr;
    typedef ServerCommandLine_ptr ServerCommandLineRef;

    class ServerCommandLine_Helper {
    public:
      typedef ServerCommandLine_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_ServerCommandLine, ServerCommandLine_Helper> ServerCommandLine_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_ServerCommandLine,ServerCommandLine_Helper > ServerCommandLine_out;

#endif

    // interface ServerCommandLine
    class ServerCommandLine {
    public:
      // Declarations for this interface type.
      typedef ServerCommandLine_ptr _ptr_type;
      typedef ServerCommandLine_var _var_type;

      static _ptr_type _duplicate(_ptr_type);
      static _ptr_type _narrow(::CORBA::Object_ptr);
      static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
      
      static _ptr_type _nil();

      static inline void _marshalObjRef(_ptr_type, cdrStream&);

      static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
        omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static _core_attr const char* _PD_repoId;

      // Other IDL defined within this scope.
      
    };

    class _objref_ServerCommandLine :
      public virtual ::CORBA::Object,
      public virtual omniObjRef
    {
    public:
      char* deviceCmdName(const char* deviceID);
      char* executeArgs(const char* deviceID, const char* args);
      Types::TStringSeq* registeredPartners(const char* deviceID);
      Types::TStringSeq* requiredPartners(const char* deviceID);

      inline _objref_ServerCommandLine()  { _PR_setobj(0); }  // nil
      _objref_ServerCommandLine(omniIOR*, omniIdentity*);

    protected:
      virtual ~_objref_ServerCommandLine();

      
    private:
      virtual void* _ptrToObjRef(const char*);

      _objref_ServerCommandLine(const _objref_ServerCommandLine&);
      _objref_ServerCommandLine& operator = (const _objref_ServerCommandLine&);
      // not implemented

      friend class ServerCommandLine;
    };

    class _pof_ServerCommandLine : public _OMNI_NS(proxyObjectFactory) {
    public:
      inline _pof_ServerCommandLine() : _OMNI_NS(proxyObjectFactory)(ServerCommandLine::_PD_repoId) {}
      virtual ~_pof_ServerCommandLine();

      virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
      virtual _CORBA_Boolean is_a(const char*) const;
    };

    class _impl_ServerCommandLine :
      public virtual omniServant
    {
    public:
      virtual ~_impl_ServerCommandLine();

      virtual char* deviceCmdName(const char* deviceID) = 0;
      virtual char* executeArgs(const char* deviceID, const char* args) = 0;
      virtual Types::TStringSeq* registeredPartners(const char* deviceID) = 0;
      virtual Types::TStringSeq* requiredPartners(const char* deviceID) = 0;
      
    public:  // Really protected, workaround for xlC
      virtual _CORBA_Boolean _dispatch(omniCallHandle&);

    private:
      virtual void* _ptrToInterface(const char*);
      virtual const char* _mostDerivedRepoId();
      
    };


  _CORBA_MODULE_END

_CORBA_MODULE_END



_CORBA_MODULE POA_STI
_CORBA_MODULE_BEG

  _CORBA_MODULE Client_Server
  _CORBA_MODULE_BEG

    class ModeInterrupt :
      public virtual STI::Client_Server::_impl_ModeInterrupt,
      public virtual ::PortableServer::ServantBase
    {
    public:
      virtual ~ModeInterrupt();

      inline ::STI::Client_Server::ModeInterrupt_ptr _this() {
        return (::STI::Client_Server::ModeInterrupt_ptr) _do_this(::STI::Client_Server::ModeInterrupt::_PD_repoId);
      }
    };

    class ModeHandler :
      public virtual STI::Client_Server::_impl_ModeHandler,
      public virtual ::PortableServer::ServantBase
    {
    public:
      virtual ~ModeHandler();

      inline ::STI::Client_Server::ModeHandler_ptr _this() {
        return (::STI::Client_Server::ModeHandler_ptr) _do_this(::STI::Client_Server::ModeHandler::_PD_repoId);
      }
    };

    class Messenger :
      public virtual STI::Client_Server::_impl_Messenger,
      public virtual ::PortableServer::ServantBase
    {
    public:
      virtual ~Messenger();

      inline ::STI::Client_Server::Messenger_ptr _this() {
        return (::STI::Client_Server::Messenger_ptr) _do_this(::STI::Client_Server::Messenger::_PD_repoId);
      }
    };

    class ClientRefresher :
      public virtual STI::Client_Server::_impl_ClientRefresher,
      public virtual ::PortableServer::ServantBase
    {
    public:
      virtual ~ClientRefresher();

      inline ::STI::Client_Server::ClientRefresher_ptr _this() {
        return (::STI::Client_Server::ClientRefresher_ptr) _do_this(::STI::Client_Server::ClientRefresher::_PD_repoId);
      }
    };

    class ServerPinger :
      public virtual STI::Client_Server::_impl_ServerPinger,
      public virtual ::PortableServer::ServantBase
    {
    public:
      virtual ~ServerPinger();

      inline ::STI::Client_Server::ServerPinger_ptr _this() {
        return (::STI::Client_Server::ServerPinger_ptr) _do_this(::STI::Client_Server::ServerPinger::_PD_repoId);
      }
    };

    class Parser :
      public virtual STI::Client_Server::_impl_Parser,
      public virtual ::PortableServer::ServantBase
    {
    public:
      virtual ~Parser();

      inline ::STI::Client_Server::Parser_ptr _this() {
        return (::STI::Client_Server::Parser_ptr) _do_this(::STI::Client_Server::Parser::_PD_repoId);
      }
    };

    class ExpSequence :
      public virtual STI::Client_Server::_impl_ExpSequence,
      public virtual ::PortableServer::ServantBase
    {
    public:
      virtual ~ExpSequence();

      inline ::STI::Client_Server::ExpSequence_ptr _this() {
        return (::STI::Client_Server::ExpSequence_ptr) _do_this(::STI::Client_Server::ExpSequence::_PD_repoId);
      }
    };

    class Control :
      public virtual STI::Client_Server::_impl_Control,
      public virtual ::PortableServer::ServantBase
    {
    public:
      virtual ~Control();

      inline ::STI::Client_Server::Control_ptr _this() {
        return (::STI::Client_Server::Control_ptr) _do_this(::STI::Client_Server::Control::_PD_repoId);
      }
    };

    class DocumentationSettings :
      public virtual STI::Client_Server::_impl_DocumentationSettings,
      public virtual ::PortableServer::ServantBase
    {
    public:
      virtual ~DocumentationSettings();

      inline ::STI::Client_Server::DocumentationSettings_ptr _this() {
        return (::STI::Client_Server::DocumentationSettings_ptr) _do_this(::STI::Client_Server::DocumentationSettings::_PD_repoId);
      }
    };

    class DeviceConfigure :
      public virtual STI::Client_Server::_impl_DeviceConfigure,
      public virtual ::PortableServer::ServantBase
    {
    public:
      virtual ~DeviceConfigure();

      inline ::STI::Client_Server::DeviceConfigure_ptr _this() {
        return (::STI::Client_Server::DeviceConfigure_ptr) _do_this(::STI::Client_Server::DeviceConfigure::_PD_repoId);
      }
    };

    class StreamingDataTransfer :
      public virtual STI::Client_Server::_impl_StreamingDataTransfer,
      public virtual ::PortableServer::ServantBase
    {
    public:
      virtual ~StreamingDataTransfer();

      inline ::STI::Client_Server::StreamingDataTransfer_ptr _this() {
        return (::STI::Client_Server::StreamingDataTransfer_ptr) _do_this(::STI::Client_Server::StreamingDataTransfer::_PD_repoId);
      }
    };

    class ServerCommandLine :
      public virtual STI::Client_Server::_impl_ServerCommandLine,
      public virtual ::PortableServer::ServantBase
    {
    public:
      virtual ~ServerCommandLine();

      inline ::STI::Client_Server::ServerCommandLine_ptr _this() {
        return (::STI::Client_Server::ServerCommandLine_ptr) _do_this(::STI::Client_Server::ServerCommandLine::_PD_repoId);
      }
    };

  _CORBA_MODULE_END

_CORBA_MODULE_END



_CORBA_MODULE OBV_STI
_CORBA_MODULE_BEG

  _CORBA_MODULE Client_Server
  _CORBA_MODULE_BEG

  _CORBA_MODULE_END

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr



inline void
STI::Client_Server::ModeInterrupt::_marshalObjRef(::STI::Client_Server::ModeInterrupt_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
STI::Client_Server::ModeHandler::_marshalObjRef(::STI::Client_Server::ModeHandler_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
STI::Client_Server::Messenger::_marshalObjRef(::STI::Client_Server::Messenger_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
STI::Client_Server::ClientRefresher::_marshalObjRef(::STI::Client_Server::ClientRefresher_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
STI::Client_Server::ServerPinger::_marshalObjRef(::STI::Client_Server::ServerPinger_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
STI::Client_Server::Parser::_marshalObjRef(::STI::Client_Server::Parser_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
STI::Client_Server::ExpSequence::_marshalObjRef(::STI::Client_Server::ExpSequence_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
STI::Client_Server::Control::_marshalObjRef(::STI::Client_Server::Control_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
STI::Client_Server::DocumentationSettings::_marshalObjRef(::STI::Client_Server::DocumentationSettings_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
STI::Client_Server::DeviceConfigure::_marshalObjRef(::STI::Client_Server::DeviceConfigure_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
STI::Client_Server::StreamingDataTransfer::_marshalObjRef(::STI::Client_Server::StreamingDataTransfer_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
STI::Client_Server::ServerCommandLine::_marshalObjRef(::STI::Client_Server::ServerCommandLine_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}




#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_client
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_client
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_client
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_client
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_client
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_client
#endif

#endif  // __client_hh__

