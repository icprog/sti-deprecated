// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef __device_hh__
#define __device_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_device
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_device
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_device
#endif



#ifndef __orbTypes_hh_EXTERNAL_GUARD__
#define __orbTypes_hh_EXTERNAL_GUARD__
#include <orbTypes.h>
#endif



#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_MODULE STI

_CORBA_MODULE_BEG

  _CORBA_MODULE Server_Device

  _CORBA_MODULE_BEG

#ifndef __STI_mServer__Device_mDataLogger__
#define __STI_mServer__Device_mDataLogger__

    class DataLogger;
    class _objref_DataLogger;
    class _impl_DataLogger;
    
    typedef _objref_DataLogger* DataLogger_ptr;
    typedef DataLogger_ptr DataLoggerRef;

    class DataLogger_Helper {
    public:
      typedef DataLogger_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_DataLogger, DataLogger_Helper> DataLogger_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_DataLogger,DataLogger_Helper > DataLogger_out;

#endif

    // interface DataLogger
    class DataLogger {
    public:
      // Declarations for this interface type.
      typedef DataLogger_ptr _ptr_type;
      typedef DataLogger_var _var_type;

      static _ptr_type _duplicate(_ptr_type);
      static _ptr_type _narrow(::CORBA::Object_ptr);
      static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
      
      static _ptr_type _nil();

      static inline void _marshalObjRef(_ptr_type, cdrStream&);

      static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
        omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static _core_attr const char* _PD_repoId;

      // Other IDL defined within this scope.
      
    };

    class _objref_DataLogger :
      public virtual ::CORBA::Object,
      public virtual omniObjRef
    {
    public:
      Types::TLogFileSeq* getLogFiles();
      void clearLocalLogFiles();

      inline _objref_DataLogger()  { _PR_setobj(0); }  // nil
      _objref_DataLogger(omniIOR*, omniIdentity*);

    protected:
      virtual ~_objref_DataLogger();

      
    private:
      virtual void* _ptrToObjRef(const char*);

      _objref_DataLogger(const _objref_DataLogger&);
      _objref_DataLogger& operator = (const _objref_DataLogger&);
      // not implemented

      friend class DataLogger;
    };

    class _pof_DataLogger : public _OMNI_NS(proxyObjectFactory) {
    public:
      inline _pof_DataLogger() : _OMNI_NS(proxyObjectFactory)(DataLogger::_PD_repoId) {}
      virtual ~_pof_DataLogger();

      virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
      virtual _CORBA_Boolean is_a(const char*) const;
    };

    class _impl_DataLogger :
      public virtual omniServant
    {
    public:
      virtual ~_impl_DataLogger();

      virtual Types::TLogFileSeq* getLogFiles() = 0;
      virtual void clearLocalLogFiles() = 0;
      
    public:  // Really protected, workaround for xlC
      virtual _CORBA_Boolean _dispatch(omniCallHandle&);

    private:
      virtual void* _ptrToInterface(const char*);
      virtual const char* _mostDerivedRepoId();
      
    };


#ifndef __STI_mServer__Device_mConfigure__
#define __STI_mServer__Device_mConfigure__

    class Configure;
    class _objref_Configure;
    class _impl_Configure;
    
    typedef _objref_Configure* Configure_ptr;
    typedef Configure_ptr ConfigureRef;

    class Configure_Helper {
    public:
      typedef Configure_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_Configure, Configure_Helper> Configure_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_Configure,Configure_Helper > Configure_out;

#endif

    // interface Configure
    class Configure {
    public:
      // Declarations for this interface type.
      typedef Configure_ptr _ptr_type;
      typedef Configure_var _var_type;

      static _ptr_type _duplicate(_ptr_type);
      static _ptr_type _narrow(::CORBA::Object_ptr);
      static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
      
      static _ptr_type _nil();

      static inline void _marshalObjRef(_ptr_type, cdrStream&);

      static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
        omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static _core_attr const char* _PD_repoId;

      // Other IDL defined within this scope.
      
    };

    class _objref_Configure :
      public virtual ::CORBA::Object,
      public virtual omniObjRef
    {
    public:
      ::CORBA::Boolean setAttribute(const char* key, const char* value);
      char* getAttribute(const char* key);
      void reRegisterWithServer();
      void kill();
      Types::TAttributeSeq* attributes();
      char* deviceName();

      inline _objref_Configure()  { _PR_setobj(0); }  // nil
      _objref_Configure(omniIOR*, omniIdentity*);

    protected:
      virtual ~_objref_Configure();

      
    private:
      virtual void* _ptrToObjRef(const char*);

      _objref_Configure(const _objref_Configure&);
      _objref_Configure& operator = (const _objref_Configure&);
      // not implemented

      friend class Configure;
    };

    class _pof_Configure : public _OMNI_NS(proxyObjectFactory) {
    public:
      inline _pof_Configure() : _OMNI_NS(proxyObjectFactory)(Configure::_PD_repoId) {}
      virtual ~_pof_Configure();

      virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
      virtual _CORBA_Boolean is_a(const char*) const;
    };

    class _impl_Configure :
      public virtual omniServant
    {
    public:
      virtual ~_impl_Configure();

      virtual ::CORBA::Boolean setAttribute(const char* key, const char* value) = 0;
      virtual char* getAttribute(const char* key) = 0;
      virtual void reRegisterWithServer() = 0;
      virtual void kill() = 0;
      virtual Types::TAttributeSeq* attributes() = 0;
      virtual char* deviceName() = 0;
      
    public:  // Really protected, workaround for xlC
      virtual _CORBA_Boolean _dispatch(omniCallHandle&);

    private:
      virtual void* _ptrToInterface(const char*);
      virtual const char* _mostDerivedRepoId();
      
    };


#ifndef __STI_mServer__Device_mDataTransfer__
#define __STI_mServer__Device_mDataTransfer__

    class DataTransfer;
    class _objref_DataTransfer;
    class _impl_DataTransfer;
    
    typedef _objref_DataTransfer* DataTransfer_ptr;
    typedef DataTransfer_ptr DataTransferRef;

    class DataTransfer_Helper {
    public:
      typedef DataTransfer_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_DataTransfer, DataTransfer_Helper> DataTransfer_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_DataTransfer,DataTransfer_Helper > DataTransfer_out;

#endif

    // interface DataTransfer
    class DataTransfer {
    public:
      // Declarations for this interface type.
      typedef DataTransfer_ptr _ptr_type;
      typedef DataTransfer_var _var_type;

      static _ptr_type _duplicate(_ptr_type);
      static _ptr_type _narrow(::CORBA::Object_ptr);
      static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
      
      static _ptr_type _nil();

      static inline void _marshalObjRef(_ptr_type, cdrStream&);

      static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
        omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static _core_attr const char* _PD_repoId;

      // Other IDL defined within this scope.
      
    };

    class _objref_DataTransfer :
      public virtual ::CORBA::Object,
      public virtual omniObjRef
    {
    public:
      Types::TMeasurementSeq* getRecentMeasurements(::CORBA::Long startingIndex);
      Types::TMeasurementSeq* getStreamingData(::CORBA::UShort channel, ::CORBA::Double initial_t, ::CORBA::Double final_t, ::CORBA::Double delta_t);
      Types::TLabeledData* getData(const char* dataLabel);
      char* errMsg();
      Types::TMeasurementSeq* measurements();

      inline _objref_DataTransfer()  { _PR_setobj(0); }  // nil
      _objref_DataTransfer(omniIOR*, omniIdentity*);

    protected:
      virtual ~_objref_DataTransfer();

      
    private:
      virtual void* _ptrToObjRef(const char*);

      _objref_DataTransfer(const _objref_DataTransfer&);
      _objref_DataTransfer& operator = (const _objref_DataTransfer&);
      // not implemented

      friend class DataTransfer;
    };

    class _pof_DataTransfer : public _OMNI_NS(proxyObjectFactory) {
    public:
      inline _pof_DataTransfer() : _OMNI_NS(proxyObjectFactory)(DataTransfer::_PD_repoId) {}
      virtual ~_pof_DataTransfer();

      virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
      virtual _CORBA_Boolean is_a(const char*) const;
    };

    class _impl_DataTransfer :
      public virtual omniServant
    {
    public:
      virtual ~_impl_DataTransfer();

      virtual Types::TMeasurementSeq* getRecentMeasurements(::CORBA::Long startingIndex) = 0;
      virtual Types::TMeasurementSeq* getStreamingData(::CORBA::UShort channel, ::CORBA::Double initial_t, ::CORBA::Double final_t, ::CORBA::Double delta_t) = 0;
      virtual Types::TLabeledData* getData(const char* dataLabel) = 0;
      virtual char* errMsg() = 0;
      virtual Types::TMeasurementSeq* measurements() = 0;
      
    public:  // Really protected, workaround for xlC
      virtual _CORBA_Boolean _dispatch(omniCallHandle&);

    private:
      virtual void* _ptrToInterface(const char*);
      virtual const char* _mostDerivedRepoId();
      
    };


#ifndef __STI_mServer__Device_mDeviceControl__
#define __STI_mServer__Device_mDeviceControl__

    class DeviceControl;
    class _objref_DeviceControl;
    class _impl_DeviceControl;
    
    typedef _objref_DeviceControl* DeviceControl_ptr;
    typedef DeviceControl_ptr DeviceControlRef;

    class DeviceControl_Helper {
    public:
      typedef DeviceControl_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_DeviceControl, DeviceControl_Helper> DeviceControl_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_DeviceControl,DeviceControl_Helper > DeviceControl_out;

#endif

    // interface DeviceControl
    class DeviceControl {
    public:
      // Declarations for this interface type.
      typedef DeviceControl_ptr _ptr_type;
      typedef DeviceControl_var _var_type;

      static _ptr_type _duplicate(_ptr_type);
      static _ptr_type _narrow(::CORBA::Object_ptr);
      static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
      
      static _ptr_type _nil();

      static inline void _marshalObjRef(_ptr_type, cdrStream&);

      static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
        omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static _core_attr const char* _PD_repoId;

      // Other IDL defined within this scope.
      
    };

    class _objref_DeviceControl :
      public virtual ::CORBA::Object,
      public virtual omniObjRef
    {
    public:
      Types::TStatus status();
      ::CORBA::Boolean transferEvents(const Types::TDeviceEventSeq& events, ::CORBA::Boolean dryrun);
      void reset();
      void load();
      ::CORBA::Boolean prepareToPlay();
      void play();
      void pause();
      void stop();
      ::CORBA::Boolean ping();
      char* controlMsg();
      char* transferErr();
      ::CORBA::Boolean eventsParsed();
      ::CORBA::Boolean eventsLoaded();
      ::CORBA::Boolean eventsPlayed();

      inline _objref_DeviceControl()  { _PR_setobj(0); }  // nil
      _objref_DeviceControl(omniIOR*, omniIdentity*);

    protected:
      virtual ~_objref_DeviceControl();

      
    private:
      virtual void* _ptrToObjRef(const char*);

      _objref_DeviceControl(const _objref_DeviceControl&);
      _objref_DeviceControl& operator = (const _objref_DeviceControl&);
      // not implemented

      friend class DeviceControl;
    };

    class _pof_DeviceControl : public _OMNI_NS(proxyObjectFactory) {
    public:
      inline _pof_DeviceControl() : _OMNI_NS(proxyObjectFactory)(DeviceControl::_PD_repoId) {}
      virtual ~_pof_DeviceControl();

      virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
      virtual _CORBA_Boolean is_a(const char*) const;
    };

    class _impl_DeviceControl :
      public virtual omniServant
    {
    public:
      virtual ~_impl_DeviceControl();

      virtual Types::TStatus status() = 0;
      virtual ::CORBA::Boolean transferEvents(const Types::TDeviceEventSeq& events, ::CORBA::Boolean dryrun) = 0;
      virtual void reset() = 0;
      virtual void load() = 0;
      virtual ::CORBA::Boolean prepareToPlay() = 0;
      virtual void play() = 0;
      virtual void pause() = 0;
      virtual void stop() = 0;
      virtual ::CORBA::Boolean ping() = 0;
      virtual char* controlMsg() = 0;
      virtual char* transferErr() = 0;
      virtual ::CORBA::Boolean eventsParsed() = 0;
      virtual ::CORBA::Boolean eventsLoaded() = 0;
      virtual ::CORBA::Boolean eventsPlayed() = 0;
      
    public:  // Really protected, workaround for xlC
      virtual _CORBA_Boolean _dispatch(omniCallHandle&);

    private:
      virtual void* _ptrToInterface(const char*);
      virtual const char* _mostDerivedRepoId();
      
    };


#ifndef __STI_mServer__Device_mServerConfigure__
#define __STI_mServer__Device_mServerConfigure__

    class ServerConfigure;
    class _objref_ServerConfigure;
    class _impl_ServerConfigure;
    
    typedef _objref_ServerConfigure* ServerConfigure_ptr;
    typedef ServerConfigure_ptr ServerConfigureRef;

    class ServerConfigure_Helper {
    public:
      typedef ServerConfigure_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_ServerConfigure, ServerConfigure_Helper> ServerConfigure_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_ServerConfigure,ServerConfigure_Helper > ServerConfigure_out;

#endif

    // interface ServerConfigure
    class ServerConfigure {
    public:
      // Declarations for this interface type.
      typedef ServerConfigure_ptr _ptr_type;
      typedef ServerConfigure_var _var_type;

      static _ptr_type _duplicate(_ptr_type);
      static _ptr_type _narrow(::CORBA::Object_ptr);
      static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
      
      static _ptr_type _nil();

      static inline void _marshalObjRef(_ptr_type, cdrStream&);

      static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
        omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static _core_attr const char* _PD_repoId;

      // Other IDL defined within this scope.
      
    };

    class _objref_ServerConfigure :
      public virtual ::CORBA::Object,
      public virtual omniObjRef
    {
    public:
      ::CORBA::Boolean registerDevice(Types::TDevice& device);
      ::CORBA::Boolean setChannels(const char* deviceID, const Types::TDeviceChannelSeq& channels);
      ::CORBA::Boolean activateDevice(const char* deviceID);
      ::CORBA::Boolean removeDevice(const char* deviceID);
      char* generateDeviceID(const Types::TDevice& device);
      void reportMessage(const char* deviceID, Types::TMessageType type, const char* message);
      void pauseServer(const char* deviceID);
      void unpauseServer(const char* deviceID);
      Types::TAttributeSeq* attributes();
      char* serverName();

      inline _objref_ServerConfigure()  { _PR_setobj(0); }  // nil
      _objref_ServerConfigure(omniIOR*, omniIdentity*);

    protected:
      virtual ~_objref_ServerConfigure();

      
    private:
      virtual void* _ptrToObjRef(const char*);

      _objref_ServerConfigure(const _objref_ServerConfigure&);
      _objref_ServerConfigure& operator = (const _objref_ServerConfigure&);
      // not implemented

      friend class ServerConfigure;
    };

    class _pof_ServerConfigure : public _OMNI_NS(proxyObjectFactory) {
    public:
      inline _pof_ServerConfigure() : _OMNI_NS(proxyObjectFactory)(ServerConfigure::_PD_repoId) {}
      virtual ~_pof_ServerConfigure();

      virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
      virtual _CORBA_Boolean is_a(const char*) const;
    };

    class _impl_ServerConfigure :
      public virtual omniServant
    {
    public:
      virtual ~_impl_ServerConfigure();

      virtual ::CORBA::Boolean registerDevice(Types::TDevice& device) = 0;
      virtual ::CORBA::Boolean setChannels(const char* deviceID, const Types::TDeviceChannelSeq& channels) = 0;
      virtual ::CORBA::Boolean activateDevice(const char* deviceID) = 0;
      virtual ::CORBA::Boolean removeDevice(const char* deviceID) = 0;
      virtual char* generateDeviceID(const Types::TDevice& device) = 0;
      virtual void reportMessage(const char* deviceID, Types::TMessageType type, const char* message) = 0;
      virtual void pauseServer(const char* deviceID) = 0;
      virtual void unpauseServer(const char* deviceID) = 0;
      virtual Types::TAttributeSeq* attributes() = 0;
      virtual char* serverName() = 0;
      
    public:  // Really protected, workaround for xlC
      virtual _CORBA_Boolean _dispatch(omniCallHandle&);

    private:
      virtual void* _ptrToInterface(const char*);
      virtual const char* _mostDerivedRepoId();
      
    };


#ifndef __STI_mServer__Device_mCommandLine__
#define __STI_mServer__Device_mCommandLine__

    class CommandLine;
    class _objref_CommandLine;
    class _impl_CommandLine;
    
    typedef _objref_CommandLine* CommandLine_ptr;
    typedef CommandLine_ptr CommandLineRef;

    class CommandLine_Helper {
    public:
      typedef CommandLine_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_CommandLine, CommandLine_Helper> CommandLine_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_CommandLine,CommandLine_Helper > CommandLine_out;

#endif

#ifndef __STI_mServer__Device_mCommandLine__
#define __STI_mServer__Device_mCommandLine__

    class CommandLine;
    class _objref_CommandLine;
    class _impl_CommandLine;
    
    typedef _objref_CommandLine* CommandLine_ptr;
    typedef CommandLine_ptr CommandLineRef;

    class CommandLine_Helper {
    public:
      typedef CommandLine_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_CommandLine, CommandLine_Helper> CommandLine_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_CommandLine,CommandLine_Helper > CommandLine_out;

#endif

    // interface CommandLine
    class CommandLine {
    public:
      // Declarations for this interface type.
      typedef CommandLine_ptr _ptr_type;
      typedef CommandLine_var _var_type;

      static _ptr_type _duplicate(_ptr_type);
      static _ptr_type _narrow(::CORBA::Object_ptr);
      static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
      
      static _ptr_type _nil();

      static inline void _marshalObjRef(_ptr_type, cdrStream&);

      static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
        omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static _core_attr const char* _PD_repoId;

      // Other IDL defined within this scope.
      
    };

    class _objref_CommandLine :
      public virtual ::CORBA::Object,
      public virtual omniObjRef
    {
    public:
      char* execute(const char* args);
      ::CORBA::Boolean setAttribute(const char* key, const char* value);
      char* getAttribute(const char* key);
      ::CORBA::Boolean writeChannel(::CORBA::UShort channel, const Types::TValMixed& value);
      ::CORBA::Boolean readChannel(::CORBA::UShort channel, const Types::TValMixed& value, Types::TDataMixed_out data);
      ::CORBA::Boolean registerPartnerDevice(CommandLine_ptr partnerCmdLine);
      ::CORBA::Boolean unregisterPartnerDevice(const char* deviceID);
      Types::TPartnerDeviceEventSeq* getPartnerEvents(const char* deviceID);
      Types::TStringSeq* eventPartnerDevices();
      Types::TStringSeq* requiredPartnerDevices();
      Types::TStringSeq* registeredPartnerDevices();
      Types::TDevice* device();

      inline _objref_CommandLine()  { _PR_setobj(0); }  // nil
      _objref_CommandLine(omniIOR*, omniIdentity*);

    protected:
      virtual ~_objref_CommandLine();

      
    private:
      virtual void* _ptrToObjRef(const char*);

      _objref_CommandLine(const _objref_CommandLine&);
      _objref_CommandLine& operator = (const _objref_CommandLine&);
      // not implemented

      friend class CommandLine;
    };

    class _pof_CommandLine : public _OMNI_NS(proxyObjectFactory) {
    public:
      inline _pof_CommandLine() : _OMNI_NS(proxyObjectFactory)(CommandLine::_PD_repoId) {}
      virtual ~_pof_CommandLine();

      virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
      virtual _CORBA_Boolean is_a(const char*) const;
    };

    class _impl_CommandLine :
      public virtual omniServant
    {
    public:
      virtual ~_impl_CommandLine();

      virtual char* execute(const char* args) = 0;
      virtual ::CORBA::Boolean setAttribute(const char* key, const char* value) = 0;
      virtual char* getAttribute(const char* key) = 0;
      virtual ::CORBA::Boolean writeChannel(::CORBA::UShort channel, const Types::TValMixed& value) = 0;
      virtual ::CORBA::Boolean readChannel(::CORBA::UShort channel, const Types::TValMixed& value, Types::TDataMixed_out data) = 0;
      virtual ::CORBA::Boolean registerPartnerDevice(CommandLine_ptr partnerCmdLine) = 0;
      virtual ::CORBA::Boolean unregisterPartnerDevice(const char* deviceID) = 0;
      virtual Types::TPartnerDeviceEventSeq* getPartnerEvents(const char* deviceID) = 0;
      virtual Types::TStringSeq* eventPartnerDevices() = 0;
      virtual Types::TStringSeq* requiredPartnerDevices() = 0;
      virtual Types::TStringSeq* registeredPartnerDevices() = 0;
      virtual Types::TDevice* device() = 0;
      
    public:  // Really protected, workaround for xlC
      virtual _CORBA_Boolean _dispatch(omniCallHandle&);

    private:
      virtual void* _ptrToInterface(const char*);
      virtual const char* _mostDerivedRepoId();
      
    };


  _CORBA_MODULE_END

_CORBA_MODULE_END



_CORBA_MODULE POA_STI
_CORBA_MODULE_BEG

  _CORBA_MODULE Server_Device
  _CORBA_MODULE_BEG

    class DataLogger :
      public virtual STI::Server_Device::_impl_DataLogger,
      public virtual ::PortableServer::ServantBase
    {
    public:
      virtual ~DataLogger();

      inline ::STI::Server_Device::DataLogger_ptr _this() {
        return (::STI::Server_Device::DataLogger_ptr) _do_this(::STI::Server_Device::DataLogger::_PD_repoId);
      }
    };

    class Configure :
      public virtual STI::Server_Device::_impl_Configure,
      public virtual ::PortableServer::ServantBase
    {
    public:
      virtual ~Configure();

      inline ::STI::Server_Device::Configure_ptr _this() {
        return (::STI::Server_Device::Configure_ptr) _do_this(::STI::Server_Device::Configure::_PD_repoId);
      }
    };

    class DataTransfer :
      public virtual STI::Server_Device::_impl_DataTransfer,
      public virtual ::PortableServer::ServantBase
    {
    public:
      virtual ~DataTransfer();

      inline ::STI::Server_Device::DataTransfer_ptr _this() {
        return (::STI::Server_Device::DataTransfer_ptr) _do_this(::STI::Server_Device::DataTransfer::_PD_repoId);
      }
    };

    class DeviceControl :
      public virtual STI::Server_Device::_impl_DeviceControl,
      public virtual ::PortableServer::ServantBase
    {
    public:
      virtual ~DeviceControl();

      inline ::STI::Server_Device::DeviceControl_ptr _this() {
        return (::STI::Server_Device::DeviceControl_ptr) _do_this(::STI::Server_Device::DeviceControl::_PD_repoId);
      }
    };

    class ServerConfigure :
      public virtual STI::Server_Device::_impl_ServerConfigure,
      public virtual ::PortableServer::ServantBase
    {
    public:
      virtual ~ServerConfigure();

      inline ::STI::Server_Device::ServerConfigure_ptr _this() {
        return (::STI::Server_Device::ServerConfigure_ptr) _do_this(::STI::Server_Device::ServerConfigure::_PD_repoId);
      }
    };

    class CommandLine :
      public virtual STI::Server_Device::_impl_CommandLine,
      public virtual ::PortableServer::ServantBase
    {
    public:
      virtual ~CommandLine();

      inline ::STI::Server_Device::CommandLine_ptr _this() {
        return (::STI::Server_Device::CommandLine_ptr) _do_this(::STI::Server_Device::CommandLine::_PD_repoId);
      }
    };

  _CORBA_MODULE_END

_CORBA_MODULE_END



_CORBA_MODULE OBV_STI
_CORBA_MODULE_BEG

  _CORBA_MODULE Server_Device
  _CORBA_MODULE_BEG

  _CORBA_MODULE_END

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr



inline void
STI::Server_Device::DataLogger::_marshalObjRef(::STI::Server_Device::DataLogger_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
STI::Server_Device::Configure::_marshalObjRef(::STI::Server_Device::Configure_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
STI::Server_Device::DataTransfer::_marshalObjRef(::STI::Server_Device::DataTransfer_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
STI::Server_Device::DeviceControl::_marshalObjRef(::STI::Server_Device::DeviceControl_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
STI::Server_Device::ServerConfigure::_marshalObjRef(::STI::Server_Device::ServerConfigure_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
STI::Server_Device::CommandLine::_marshalObjRef(::STI::Server_Device::CommandLine_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}




#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_device
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_device
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_device
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_device
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_device
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_device
#endif

#endif  // __device_hh__

