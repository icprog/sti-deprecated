// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef __device_hh__
#define __device_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_device
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_device
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_device
#endif



#ifndef __orbTypes_hh_EXTERNAL_GUARD__
#define __orbTypes_hh_EXTERNAL_GUARD__
#include <orbTypes.h>
#endif
#ifndef __pusher_hh_EXTERNAL_GUARD__
#define __pusher_hh_EXTERNAL_GUARD__
#include <pusher.h>
#endif



#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_MODULE STI

_CORBA_MODULE_BEG

  _CORBA_MODULE Server_Device

  _CORBA_MODULE_BEG

#ifndef __STI_mServer__Device_mDataLogger__
#define __STI_mServer__Device_mDataLogger__

    class DataLogger;
    class _objref_DataLogger;
    class _impl_DataLogger;
    
    typedef _objref_DataLogger* DataLogger_ptr;
    typedef DataLogger_ptr DataLoggerRef;

    class DataLogger_Helper {
    public:
      typedef DataLogger_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_DataLogger, DataLogger_Helper> DataLogger_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_DataLogger,DataLogger_Helper > DataLogger_out;

#endif

    // interface DataLogger
    class DataLogger {
    public:
      // Declarations for this interface type.
      typedef DataLogger_ptr _ptr_type;
      typedef DataLogger_var _var_type;

      static _ptr_type _duplicate(_ptr_type);
      static _ptr_type _narrow(::CORBA::Object_ptr);
      static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
      
      static _ptr_type _nil();

      static inline void _marshalObjRef(_ptr_type, cdrStream&);

      static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
        omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static _core_attr const char* _PD_repoId;

      // Other IDL defined within this scope.
      
    };

    class _objref_DataLogger :
      public virtual ::CORBA::Object,
      public virtual omniObjRef
    {
    public:
      Types::TLogFileSeq* getLogFiles();
      void clearLocalLogFiles();

      inline _objref_DataLogger()  { _PR_setobj(0); }  // nil
      _objref_DataLogger(omniIOR*, omniIdentity*);

    protected:
      virtual ~_objref_DataLogger();

      
    private:
      virtual void* _ptrToObjRef(const char*);

      _objref_DataLogger(const _objref_DataLogger&);
      _objref_DataLogger& operator = (const _objref_DataLogger&);
      // not implemented

      friend class DataLogger;
    };

    class _pof_DataLogger : public _OMNI_NS(proxyObjectFactory) {
    public:
      inline _pof_DataLogger() : _OMNI_NS(proxyObjectFactory)(DataLogger::_PD_repoId) {}
      virtual ~_pof_DataLogger();

      virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
      virtual _CORBA_Boolean is_a(const char*) const;
    };

    class _impl_DataLogger :
      public virtual omniServant
    {
    public:
      virtual ~_impl_DataLogger();

      virtual Types::TLogFileSeq* getLogFiles() = 0;
      virtual void clearLocalLogFiles() = 0;
      
    public:  // Really protected, workaround for xlC
      virtual _CORBA_Boolean _dispatch(omniCallHandle&);

    private:
      virtual void* _ptrToInterface(const char*);
      virtual const char* _mostDerivedRepoId();
      
    };


#ifndef __STI_mServer__Device_mCommandLine__
#define __STI_mServer__Device_mCommandLine__

    class CommandLine;
    class _objref_CommandLine;
    class _impl_CommandLine;
    
    typedef _objref_CommandLine* CommandLine_ptr;
    typedef CommandLine_ptr CommandLineRef;

    class CommandLine_Helper {
    public:
      typedef CommandLine_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_CommandLine, CommandLine_Helper> CommandLine_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_CommandLine,CommandLine_Helper > CommandLine_out;

#endif

#ifndef __STI_mServer__Device_mCommandLine__
#define __STI_mServer__Device_mCommandLine__

    class CommandLine;
    class _objref_CommandLine;
    class _impl_CommandLine;
    
    typedef _objref_CommandLine* CommandLine_ptr;
    typedef CommandLine_ptr CommandLineRef;

    class CommandLine_Helper {
    public:
      typedef CommandLine_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_CommandLine, CommandLine_Helper> CommandLine_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_CommandLine,CommandLine_Helper > CommandLine_out;

#endif

    // interface CommandLine
    class CommandLine {
    public:
      // Declarations for this interface type.
      typedef CommandLine_ptr _ptr_type;
      typedef CommandLine_var _var_type;

      static _ptr_type _duplicate(_ptr_type);
      static _ptr_type _narrow(::CORBA::Object_ptr);
      static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
      
      static _ptr_type _nil();

      static inline void _marshalObjRef(_ptr_type, cdrStream&);

      static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
        omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static _core_attr const char* _PD_repoId;

      // Other IDL defined within this scope.
      
    };

    class _objref_CommandLine :
      public virtual ::CORBA::Object,
      public virtual omniObjRef
    {
    public:
      char* execute(const char* args);
      ::CORBA::Boolean setAttribute(const char* key, const char* value);
      char* getAttribute(const char* key);
      ::CORBA::Boolean registerPartnerDevice(CommandLine_ptr partnerCmdLine);
      ::CORBA::Boolean unregisterPartnerDevice(const char* deviceID);
      Types::TPartnerDeviceEventSeq* getPartnerEvents(const char* deviceID);
      ::CORBA::Boolean writeChannel(::CORBA::UShort channel, const Types::TValMixed& value);
      ::CORBA::Boolean readChannel(::CORBA::UShort channel, const Types::TValMixed& value, Types::TDataMixed_out data);
      ::CORBA::Boolean ping();
      Types::TStringSeq* eventPartnerDevices();
      Types::TStringSeq* requiredPartnerDevices();
      Types::TStringSeq* registeredPartnerDevices();
      Types::TDevice* device();

      inline _objref_CommandLine()  { _PR_setobj(0); }  // nil
      _objref_CommandLine(omniIOR*, omniIdentity*);

    protected:
      virtual ~_objref_CommandLine();

      
    private:
      virtual void* _ptrToObjRef(const char*);

      _objref_CommandLine(const _objref_CommandLine&);
      _objref_CommandLine& operator = (const _objref_CommandLine&);
      // not implemented

      friend class CommandLine;
    };

    class _pof_CommandLine : public _OMNI_NS(proxyObjectFactory) {
    public:
      inline _pof_CommandLine() : _OMNI_NS(proxyObjectFactory)(CommandLine::_PD_repoId) {}
      virtual ~_pof_CommandLine();

      virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
      virtual _CORBA_Boolean is_a(const char*) const;
    };

    class _impl_CommandLine :
      public virtual omniServant
    {
    public:
      virtual ~_impl_CommandLine();

      virtual char* execute(const char* args) = 0;
      virtual ::CORBA::Boolean setAttribute(const char* key, const char* value) = 0;
      virtual char* getAttribute(const char* key) = 0;
      virtual ::CORBA::Boolean registerPartnerDevice(CommandLine_ptr partnerCmdLine) = 0;
      virtual ::CORBA::Boolean unregisterPartnerDevice(const char* deviceID) = 0;
      virtual Types::TPartnerDeviceEventSeq* getPartnerEvents(const char* deviceID) = 0;
      virtual ::CORBA::Boolean writeChannel(::CORBA::UShort channel, const Types::TValMixed& value) = 0;
      virtual ::CORBA::Boolean readChannel(::CORBA::UShort channel, const Types::TValMixed& value, Types::TDataMixed_out data) = 0;
      virtual ::CORBA::Boolean ping() = 0;
      virtual Types::TStringSeq* eventPartnerDevices() = 0;
      virtual Types::TStringSeq* requiredPartnerDevices() = 0;
      virtual Types::TStringSeq* registeredPartnerDevices() = 0;
      virtual Types::TDevice* device() = 0;
      
    public:  // Really protected, workaround for xlC
      virtual _CORBA_Boolean _dispatch(omniCallHandle&);

    private:
      virtual void* _ptrToInterface(const char*);
      virtual const char* _mostDerivedRepoId();
      
    };


#ifndef __STI_mServer__Device_mDeviceConfigure__
#define __STI_mServer__Device_mDeviceConfigure__

    class DeviceConfigure;
    class _objref_DeviceConfigure;
    class _impl_DeviceConfigure;
    
    typedef _objref_DeviceConfigure* DeviceConfigure_ptr;
    typedef DeviceConfigure_ptr DeviceConfigureRef;

    class DeviceConfigure_Helper {
    public:
      typedef DeviceConfigure_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_DeviceConfigure, DeviceConfigure_Helper> DeviceConfigure_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_DeviceConfigure,DeviceConfigure_Helper > DeviceConfigure_out;

#endif

    // interface DeviceConfigure
    class DeviceConfigure {
    public:
      // Declarations for this interface type.
      typedef DeviceConfigure_ptr _ptr_type;
      typedef DeviceConfigure_var _var_type;

      static _ptr_type _duplicate(_ptr_type);
      static _ptr_type _narrow(::CORBA::Object_ptr);
      static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
      
      static _ptr_type _nil();

      static inline void _marshalObjRef(_ptr_type, cdrStream&);

      static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
        omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static _core_attr const char* _PD_repoId;

      // Other IDL defined within this scope.
      
    };

    class _objref_DeviceConfigure :
      public virtual ::CORBA::Object,
      public virtual omniObjRef
    {
    public:
      ::CORBA::Boolean setAttribute(const char* key, const char* value);
      char* getAttribute(const char* key);
      ::CORBA::Boolean setChannel(::CORBA::Short channel, const Types::TValMixed& value);
      void reRegisterWithServer();
      void kill();
      ::CORBA::Boolean ping();
      Types::TAttributeSeq* attributes();
      Types::TDeviceChannelSeq* channels();

      inline _objref_DeviceConfigure()  { _PR_setobj(0); }  // nil
      _objref_DeviceConfigure(omniIOR*, omniIdentity*);

    protected:
      virtual ~_objref_DeviceConfigure();

      
    private:
      virtual void* _ptrToObjRef(const char*);

      _objref_DeviceConfigure(const _objref_DeviceConfigure&);
      _objref_DeviceConfigure& operator = (const _objref_DeviceConfigure&);
      // not implemented

      friend class DeviceConfigure;
    };

    class _pof_DeviceConfigure : public _OMNI_NS(proxyObjectFactory) {
    public:
      inline _pof_DeviceConfigure() : _OMNI_NS(proxyObjectFactory)(DeviceConfigure::_PD_repoId) {}
      virtual ~_pof_DeviceConfigure();

      virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
      virtual _CORBA_Boolean is_a(const char*) const;
    };

    class _impl_DeviceConfigure :
      public virtual omniServant
    {
    public:
      virtual ~_impl_DeviceConfigure();

      virtual ::CORBA::Boolean setAttribute(const char* key, const char* value) = 0;
      virtual char* getAttribute(const char* key) = 0;
      virtual ::CORBA::Boolean setChannel(::CORBA::Short channel, const Types::TValMixed& value) = 0;
      virtual void reRegisterWithServer() = 0;
      virtual void kill() = 0;
      virtual ::CORBA::Boolean ping() = 0;
      virtual Types::TAttributeSeq* attributes() = 0;
      virtual Types::TDeviceChannelSeq* channels() = 0;
      
    public:  // Really protected, workaround for xlC
      virtual _CORBA_Boolean _dispatch(omniCallHandle&);

    private:
      virtual void* _ptrToInterface(const char*);
      virtual const char* _mostDerivedRepoId();
      
    };


#ifndef __STI_mServer__Device_mDataTransfer__
#define __STI_mServer__Device_mDataTransfer__

    class DataTransfer;
    class _objref_DataTransfer;
    class _impl_DataTransfer;
    
    typedef _objref_DataTransfer* DataTransfer_ptr;
    typedef DataTransfer_ptr DataTransferRef;

    class DataTransfer_Helper {
    public:
      typedef DataTransfer_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_DataTransfer, DataTransfer_Helper> DataTransfer_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_DataTransfer,DataTransfer_Helper > DataTransfer_out;

#endif

    // interface DataTransfer
    class DataTransfer {
    public:
      // Declarations for this interface type.
      typedef DataTransfer_ptr _ptr_type;
      typedef DataTransfer_var _var_type;

      static _ptr_type _duplicate(_ptr_type);
      static _ptr_type _narrow(::CORBA::Object_ptr);
      static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
      
      static _ptr_type _nil();

      static inline void _marshalObjRef(_ptr_type, cdrStream&);

      static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
        omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static _core_attr const char* _PD_repoId;

      // Other IDL defined within this scope.
      
    };

    class _objref_DataTransfer :
      public virtual ::CORBA::Object,
      public virtual omniObjRef
    {
    public:
      Types::TMeasurementSeq* getRecentMeasurements(::CORBA::Long startingIndex);
      Types::TMeasurementSeq* getStreamingData(::CORBA::UShort channel, ::CORBA::Double initial_t, ::CORBA::Double final_t, ::CORBA::Double delta_t);
      Types::TLabeledData* getData(const char* dataLabel);
      ::CORBA::Boolean ping();
      Types::TMeasurementSeq* measurements();

      inline _objref_DataTransfer()  { _PR_setobj(0); }  // nil
      _objref_DataTransfer(omniIOR*, omniIdentity*);

    protected:
      virtual ~_objref_DataTransfer();

      
    private:
      virtual void* _ptrToObjRef(const char*);

      _objref_DataTransfer(const _objref_DataTransfer&);
      _objref_DataTransfer& operator = (const _objref_DataTransfer&);
      // not implemented

      friend class DataTransfer;
    };

    class _pof_DataTransfer : public _OMNI_NS(proxyObjectFactory) {
    public:
      inline _pof_DataTransfer() : _OMNI_NS(proxyObjectFactory)(DataTransfer::_PD_repoId) {}
      virtual ~_pof_DataTransfer();

      virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
      virtual _CORBA_Boolean is_a(const char*) const;
    };

    class _impl_DataTransfer :
      public virtual omniServant
    {
    public:
      virtual ~_impl_DataTransfer();

      virtual Types::TMeasurementSeq* getRecentMeasurements(::CORBA::Long startingIndex) = 0;
      virtual Types::TMeasurementSeq* getStreamingData(::CORBA::UShort channel, ::CORBA::Double initial_t, ::CORBA::Double final_t, ::CORBA::Double delta_t) = 0;
      virtual Types::TLabeledData* getData(const char* dataLabel) = 0;
      virtual ::CORBA::Boolean ping() = 0;
      virtual Types::TMeasurementSeq* measurements() = 0;
      
    public:  // Really protected, workaround for xlC
      virtual _CORBA_Boolean _dispatch(omniCallHandle&);

    private:
      virtual void* _ptrToInterface(const char*);
      virtual const char* _mostDerivedRepoId();
      
    };


#ifndef __STI_mServer__Device_mDeviceTimingSeqControl__
#define __STI_mServer__Device_mDeviceTimingSeqControl__

    class DeviceTimingSeqControl;
    class _objref_DeviceTimingSeqControl;
    class _impl_DeviceTimingSeqControl;
    
    typedef _objref_DeviceTimingSeqControl* DeviceTimingSeqControl_ptr;
    typedef DeviceTimingSeqControl_ptr DeviceTimingSeqControlRef;

    class DeviceTimingSeqControl_Helper {
    public:
      typedef DeviceTimingSeqControl_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_DeviceTimingSeqControl, DeviceTimingSeqControl_Helper> DeviceTimingSeqControl_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_DeviceTimingSeqControl,DeviceTimingSeqControl_Helper > DeviceTimingSeqControl_out;

#endif

    // interface DeviceTimingSeqControl
    class DeviceTimingSeqControl {
    public:
      // Declarations for this interface type.
      typedef DeviceTimingSeqControl_ptr _ptr_type;
      typedef DeviceTimingSeqControl_var _var_type;

      static _ptr_type _duplicate(_ptr_type);
      static _ptr_type _narrow(::CORBA::Object_ptr);
      static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
      
      static _ptr_type _nil();

      static inline void _marshalObjRef(_ptr_type, cdrStream&);

      static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
        omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static _core_attr const char* _PD_repoId;

      // Other IDL defined within this scope.
      
    };

    class _objref_DeviceTimingSeqControl :
      public virtual ::CORBA::Object,
      public virtual omniObjRef
    {
    public:
      ::CORBA::Boolean transferEvents(const Types::TDeviceEventSeq& events, ::CORBA::Boolean dryrun);
      void reset();
      void load();
      ::CORBA::Boolean prepareToPlay();
      void play();
      void pause();
      void stop();
      ::CORBA::Boolean ping();
      char* transferErr();
      ::CORBA::Boolean eventsParsed();
      ::CORBA::Boolean eventsLoaded();
      ::CORBA::Boolean eventsPlayed();

      inline _objref_DeviceTimingSeqControl()  { _PR_setobj(0); }  // nil
      _objref_DeviceTimingSeqControl(omniIOR*, omniIdentity*);

    protected:
      virtual ~_objref_DeviceTimingSeqControl();

      
    private:
      virtual void* _ptrToObjRef(const char*);

      _objref_DeviceTimingSeqControl(const _objref_DeviceTimingSeqControl&);
      _objref_DeviceTimingSeqControl& operator = (const _objref_DeviceTimingSeqControl&);
      // not implemented

      friend class DeviceTimingSeqControl;
    };

    class _pof_DeviceTimingSeqControl : public _OMNI_NS(proxyObjectFactory) {
    public:
      inline _pof_DeviceTimingSeqControl() : _OMNI_NS(proxyObjectFactory)(DeviceTimingSeqControl::_PD_repoId) {}
      virtual ~_pof_DeviceTimingSeqControl();

      virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
      virtual _CORBA_Boolean is_a(const char*) const;
    };

    class _impl_DeviceTimingSeqControl :
      public virtual omniServant
    {
    public:
      virtual ~_impl_DeviceTimingSeqControl();

      virtual ::CORBA::Boolean transferEvents(const Types::TDeviceEventSeq& events, ::CORBA::Boolean dryrun) = 0;
      virtual void reset() = 0;
      virtual void load() = 0;
      virtual ::CORBA::Boolean prepareToPlay() = 0;
      virtual void play() = 0;
      virtual void pause() = 0;
      virtual void stop() = 0;
      virtual ::CORBA::Boolean ping() = 0;
      virtual char* transferErr() = 0;
      virtual ::CORBA::Boolean eventsParsed() = 0;
      virtual ::CORBA::Boolean eventsLoaded() = 0;
      virtual ::CORBA::Boolean eventsPlayed() = 0;
      
    public:  // Really protected, workaround for xlC
      virtual _CORBA_Boolean _dispatch(omniCallHandle&);

    private:
      virtual void* _ptrToInterface(const char*);
      virtual const char* _mostDerivedRepoId();
      
    };


#ifndef __STI_mServer__Device_mDeviceBootstrap__
#define __STI_mServer__Device_mDeviceBootstrap__

    class DeviceBootstrap;
    class _objref_DeviceBootstrap;
    class _impl_DeviceBootstrap;
    
    typedef _objref_DeviceBootstrap* DeviceBootstrap_ptr;
    typedef DeviceBootstrap_ptr DeviceBootstrapRef;

    class DeviceBootstrap_Helper {
    public:
      typedef DeviceBootstrap_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_DeviceBootstrap, DeviceBootstrap_Helper> DeviceBootstrap_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_DeviceBootstrap,DeviceBootstrap_Helper > DeviceBootstrap_out;

#endif

    // interface DeviceBootstrap
    class DeviceBootstrap {
    public:
      // Declarations for this interface type.
      typedef DeviceBootstrap_ptr _ptr_type;
      typedef DeviceBootstrap_var _var_type;

      static _ptr_type _duplicate(_ptr_type);
      static _ptr_type _narrow(::CORBA::Object_ptr);
      static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
      
      static _ptr_type _nil();

      static inline void _marshalObjRef(_ptr_type, cdrStream&);

      static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
        omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static _core_attr const char* _PD_repoId;

      // Other IDL defined within this scope.
      
    };

    class _objref_DeviceBootstrap :
      public virtual ::CORBA::Object,
      public virtual omniObjRef
    {
    public:
      ::CORBA::Boolean ping();
      Types::TDevice* getDevice();
      DeviceTimingSeqControl_ptr getDeviceTimingSeqControl();
      DataTransfer_ptr getDataTransfer();
      DeviceConfigure_ptr getDeviceConfigure();
      CommandLine_ptr getCommandLine();

      inline _objref_DeviceBootstrap()  { _PR_setobj(0); }  // nil
      _objref_DeviceBootstrap(omniIOR*, omniIdentity*);

    protected:
      virtual ~_objref_DeviceBootstrap();

      
    private:
      virtual void* _ptrToObjRef(const char*);

      _objref_DeviceBootstrap(const _objref_DeviceBootstrap&);
      _objref_DeviceBootstrap& operator = (const _objref_DeviceBootstrap&);
      // not implemented

      friend class DeviceBootstrap;
    };

    class _pof_DeviceBootstrap : public _OMNI_NS(proxyObjectFactory) {
    public:
      inline _pof_DeviceBootstrap() : _OMNI_NS(proxyObjectFactory)(DeviceBootstrap::_PD_repoId) {}
      virtual ~_pof_DeviceBootstrap();

      virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
      virtual _CORBA_Boolean is_a(const char*) const;
    };

    class _impl_DeviceBootstrap :
      public virtual omniServant
    {
    public:
      virtual ~_impl_DeviceBootstrap();

      virtual ::CORBA::Boolean ping() = 0;
      virtual Types::TDevice* getDevice() = 0;
      virtual DeviceTimingSeqControl_ptr getDeviceTimingSeqControl() = 0;
      virtual DataTransfer_ptr getDataTransfer() = 0;
      virtual DeviceConfigure_ptr getDeviceConfigure() = 0;
      virtual CommandLine_ptr getCommandLine() = 0;
      
    public:  // Really protected, workaround for xlC
      virtual _CORBA_Boolean _dispatch(omniCallHandle&);

    private:
      virtual void* _ptrToInterface(const char*);
      virtual const char* _mostDerivedRepoId();
      
    };


#ifndef __STI_mServer__Device_mServerConfigure__
#define __STI_mServer__Device_mServerConfigure__

    class ServerConfigure;
    class _objref_ServerConfigure;
    class _impl_ServerConfigure;
    
    typedef _objref_ServerConfigure* ServerConfigure_ptr;
    typedef ServerConfigure_ptr ServerConfigureRef;

    class ServerConfigure_Helper {
    public:
      typedef ServerConfigure_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_ServerConfigure, ServerConfigure_Helper> ServerConfigure_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_ServerConfigure,ServerConfigure_Helper > ServerConfigure_out;

#endif

    // interface ServerConfigure
    class ServerConfigure {
    public:
      // Declarations for this interface type.
      typedef ServerConfigure_ptr _ptr_type;
      typedef ServerConfigure_var _var_type;

      static _ptr_type _duplicate(_ptr_type);
      static _ptr_type _narrow(::CORBA::Object_ptr);
      static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
      
      static _ptr_type _nil();

      static inline void _marshalObjRef(_ptr_type, cdrStream&);

      static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
        omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static _core_attr const char* _PD_repoId;

      // Other IDL defined within this scope.
      
    };

    class _objref_ServerConfigure :
      public virtual ::CORBA::Object,
      public virtual omniObjRef
    {
    public:
      ::CORBA::Boolean registerDevice(Types::TDevice& device, DeviceBootstrap_ptr bootstrap);
      ::CORBA::Boolean removeDevice(const char* deviceID);
      char* generateDeviceID(const Types::TDevice& device);
      void pauseServer(const char* deviceID);
      void unpauseServer(const char* deviceID);
      Pusher::DeviceEventHandler_ptr getDeviceEventHandler();
      ::CORBA::Boolean ping();

      inline _objref_ServerConfigure()  { _PR_setobj(0); }  // nil
      _objref_ServerConfigure(omniIOR*, omniIdentity*);

    protected:
      virtual ~_objref_ServerConfigure();

      
    private:
      virtual void* _ptrToObjRef(const char*);

      _objref_ServerConfigure(const _objref_ServerConfigure&);
      _objref_ServerConfigure& operator = (const _objref_ServerConfigure&);
      // not implemented

      friend class ServerConfigure;
    };

    class _pof_ServerConfigure : public _OMNI_NS(proxyObjectFactory) {
    public:
      inline _pof_ServerConfigure() : _OMNI_NS(proxyObjectFactory)(ServerConfigure::_PD_repoId) {}
      virtual ~_pof_ServerConfigure();

      virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
      virtual _CORBA_Boolean is_a(const char*) const;
    };

    class _impl_ServerConfigure :
      public virtual omniServant
    {
    public:
      virtual ~_impl_ServerConfigure();

      virtual ::CORBA::Boolean registerDevice(Types::TDevice& device, DeviceBootstrap_ptr bootstrap) = 0;
      virtual ::CORBA::Boolean removeDevice(const char* deviceID) = 0;
      virtual char* generateDeviceID(const Types::TDevice& device) = 0;
      virtual void pauseServer(const char* deviceID) = 0;
      virtual void unpauseServer(const char* deviceID) = 0;
      virtual Pusher::DeviceEventHandler_ptr getDeviceEventHandler() = 0;
      virtual ::CORBA::Boolean ping() = 0;
      
    public:  // Really protected, workaround for xlC
      virtual _CORBA_Boolean _dispatch(omniCallHandle&);

    private:
      virtual void* _ptrToInterface(const char*);
      virtual const char* _mostDerivedRepoId();
      
    };


  _CORBA_MODULE_END

_CORBA_MODULE_END



_CORBA_MODULE POA_STI
_CORBA_MODULE_BEG

  _CORBA_MODULE Server_Device
  _CORBA_MODULE_BEG

    class DataLogger :
      public virtual STI::Server_Device::_impl_DataLogger,
      public virtual ::PortableServer::ServantBase
    {
    public:
      virtual ~DataLogger();

      inline ::STI::Server_Device::DataLogger_ptr _this() {
        return (::STI::Server_Device::DataLogger_ptr) _do_this(::STI::Server_Device::DataLogger::_PD_repoId);
      }
    };

    class CommandLine :
      public virtual STI::Server_Device::_impl_CommandLine,
      public virtual ::PortableServer::ServantBase
    {
    public:
      virtual ~CommandLine();

      inline ::STI::Server_Device::CommandLine_ptr _this() {
        return (::STI::Server_Device::CommandLine_ptr) _do_this(::STI::Server_Device::CommandLine::_PD_repoId);
      }
    };

    class DeviceConfigure :
      public virtual STI::Server_Device::_impl_DeviceConfigure,
      public virtual ::PortableServer::ServantBase
    {
    public:
      virtual ~DeviceConfigure();

      inline ::STI::Server_Device::DeviceConfigure_ptr _this() {
        return (::STI::Server_Device::DeviceConfigure_ptr) _do_this(::STI::Server_Device::DeviceConfigure::_PD_repoId);
      }
    };

    class DataTransfer :
      public virtual STI::Server_Device::_impl_DataTransfer,
      public virtual ::PortableServer::ServantBase
    {
    public:
      virtual ~DataTransfer();

      inline ::STI::Server_Device::DataTransfer_ptr _this() {
        return (::STI::Server_Device::DataTransfer_ptr) _do_this(::STI::Server_Device::DataTransfer::_PD_repoId);
      }
    };

    class DeviceTimingSeqControl :
      public virtual STI::Server_Device::_impl_DeviceTimingSeqControl,
      public virtual ::PortableServer::ServantBase
    {
    public:
      virtual ~DeviceTimingSeqControl();

      inline ::STI::Server_Device::DeviceTimingSeqControl_ptr _this() {
        return (::STI::Server_Device::DeviceTimingSeqControl_ptr) _do_this(::STI::Server_Device::DeviceTimingSeqControl::_PD_repoId);
      }
    };

    class DeviceBootstrap :
      public virtual STI::Server_Device::_impl_DeviceBootstrap,
      public virtual ::PortableServer::ServantBase
    {
    public:
      virtual ~DeviceBootstrap();

      inline ::STI::Server_Device::DeviceBootstrap_ptr _this() {
        return (::STI::Server_Device::DeviceBootstrap_ptr) _do_this(::STI::Server_Device::DeviceBootstrap::_PD_repoId);
      }
    };

    class ServerConfigure :
      public virtual STI::Server_Device::_impl_ServerConfigure,
      public virtual ::PortableServer::ServantBase
    {
    public:
      virtual ~ServerConfigure();

      inline ::STI::Server_Device::ServerConfigure_ptr _this() {
        return (::STI::Server_Device::ServerConfigure_ptr) _do_this(::STI::Server_Device::ServerConfigure::_PD_repoId);
      }
    };

  _CORBA_MODULE_END

_CORBA_MODULE_END



_CORBA_MODULE OBV_STI
_CORBA_MODULE_BEG

  _CORBA_MODULE Server_Device
  _CORBA_MODULE_BEG

  _CORBA_MODULE_END

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr



inline void
STI::Server_Device::DataLogger::_marshalObjRef(::STI::Server_Device::DataLogger_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
STI::Server_Device::CommandLine::_marshalObjRef(::STI::Server_Device::CommandLine_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
STI::Server_Device::DeviceConfigure::_marshalObjRef(::STI::Server_Device::DeviceConfigure_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
STI::Server_Device::DataTransfer::_marshalObjRef(::STI::Server_Device::DataTransfer_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
STI::Server_Device::DeviceTimingSeqControl::_marshalObjRef(::STI::Server_Device::DeviceTimingSeqControl_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
STI::Server_Device::DeviceBootstrap::_marshalObjRef(::STI::Server_Device::DeviceBootstrap_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
STI::Server_Device::ServerConfigure::_marshalObjRef(::STI::Server_Device::ServerConfigure_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}




#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_device
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_device
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_device
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_device
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_device
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_device
#endif

#endif  // __device_hh__

