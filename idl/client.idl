/*! \file
 *  \author Jonathan David Harvey
 *  \author Jason Michael Hogan
 *  \author David Marvin Slaughter Johnson
 *  \author Olaf Mandel
 *  \brief Interface Definition of the Client-Server CORBA communication.
 *  \section license License
 *
 *  Copyright (C) 2008 Jonathan Harvey <harv@stanford.edu>\n
 *  Copyright (C) 2008 Jason Hogan <hogan@stanford.edu>\n
 *  Copyright (C) 2008 David Johnson <dmsj@stanford.edu>\n
 *  Copyright (C) 2008 Olaf Mandel <mandel@stanford.edu>\n
 *  This file is part of Stanford Timing Interface (STI).
 *
 *  STI is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  STI is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with STI.  If not, see <http://www.gnu.org/licenses/>.
 */
#ifndef CLIENT_IDL
#define CLIENT_IDL

#include "orbTypes.idl"
#include "pusher.idl"

module STI
{

module Client_Server
{
	interface ModeHandler;
	interface Parser;
	interface ExpSequence;
	interface ServerTimingSeqControl;
	interface RegisteredDevices;
	interface ServerCommandLine;

	interface ClientBootstrap
	{
		boolean connect(in STI::Pusher::ServerEventHandler eventHandler);
		
		ModeHandler getModeHandler();
		Parser getParser();
		ExpSequence getExpSequence();
		ServerTimingSeqControl getServerTimingSeqControl();
		RegisteredDevices getRegisteredDevices();
		ServerCommandLine getServerCommandLine();
	};



	interface ModeInterrupt
	{
		void requestControl(in string myName, in string ipAddress);
		void controlTakenBy(in string myName, in string ipAddress);
	};

    interface ModeHandler
    {
		readonly attribute string controllerName;
		readonly attribute string controllerIP;

		boolean requestControl(in string myName, in string ipAddress, in ModeInterrupt interrupt);
		boolean takeControl(in string myName, in string ipAddress, in ModeInterrupt interrupt);
		void cancelRequest();

        void answerRequest(in boolean yield);
    };


	// For callbacks to the client
	//interface Messenger
	//{
	//	void sendMessage(in string message);
	//};


	////used by the server to refresh a client (only "awake" clients need to be refreshed)
	//interface ClientRefresher
	//{
	//	//the server reports a message to the server about a device
	//	void reportDeviceMessage(in string deviceID, in STI::Types::TMessageType type, in string message);

	//	//the server forces the client to refresh the attributes of a device
	//	void forceDeviceAttributeRefresh(in string deviceID);
	//};

	////used by the client to tell the server it is "awake"
	//interface ServerPinger
	//{
	//	void pingServer(in ClientRefresher refresher);	//should only add if this is a new obj reference
	//};

    interface Parser
    {
        boolean parseFile(in string filename);
		boolean parseLoopScript(in string script);

		STI::Types::TChannelSeq channels(in STI::Types::TEngineID engineID);
		STI::Types::TStringSeq files(in STI::Types::TEngineID engineID);
		STI::Types::TEventSeq events(in STI::Types::TEngineID engineID);

		STI::Types::TVariableSeq variables(in STI::Types::TEngineID engineID);
		STI::Types::TOverwrittenSeq overwritten(in STI::Types::TEngineID engineID);
	};

    interface Parser
    {
        //Set this before parsing
        attribute STI::Types::TOverwrittenSeq overwritten;

        //Parse with one of these
        //Both return true on error
        boolean parseFile(in string filename);
        boolean parseString(in string code);
		boolean parseLoopScript(in string script);		//for generating the ExpSequence from a script

		boolean stringToMixedValue(in string code, out STI::Types::TValMixed value);

        //Harvest the parsing result here:
        readonly attribute string       outMsg;
        readonly attribute string       errMsg;
        readonly attribute string       mainFile;
        readonly attribute STI::Types::TChannelSeq  channels;
        readonly attribute STI::Types::TStringSeq   files;
        readonly attribute STI::Types::TVariableSeq variables;
        readonly attribute STI::Types::TEventSeq    events;
	
    };

    interface ExpSequence
    {
		boolean setExpSequence(in STI::Types::TStringSeq Variables, in STI::Types::TRowSeq Experiments);

        attribute STI::Types::TStringSeq       variables; //ColumnHeaders
        readonly attribute STI::Types::TRowSeq experiments;
        
        //All return true on error
        boolean appendRow(in STI::Types::TStringSeq newRow);
        boolean moveRow(in unsigned long oldPos, in unsigned long newPos);
        boolean editRow(in unsigned long pos, in STI::Types::TRow newRow);
		boolean deleteRow(in unsigned long pos);
		void clear();

		boolean editRowDone(in unsigned long pos, in boolean newDone);
    };

	//Server-side
    interface ServerTimingSeqControl	//need to upgrade (and rename) to account for EngineID selection
    {
		void runSingle(in boolean documented);   //Uses Parser.overwritten as it currently is.
        void runSequence(in boolean documented); //Sets Parser.overwritten from ExpSequence
		void runSingleContinuous();
		
		void pause();
		void resume();
        void stop();
    };

	//Server-side
	interface DocumentationSettings
	{
		attribute string DocumentationBaseAbsDir;
		attribute string DTDFileAbsDir;

		//Each documented trial has files placed in a base directory with these sub-directories:
		attribute string TimingFilesRelDir;
		attribute string DataFilesRelDir;
		attribute string ExperimentFilesRelDir;
		attribute string SequenceFilesRelDir;

		void setSequenceDescription(in string seqDescription);
	};

	// Server-side servant
    interface RegisteredDevices
    {
        readonly attribute STI::Types::TDeviceSeq devices;

        STI::Types::TAttributeSeq getDeviceAttributes(in string deviceID);
        boolean setDeviceAttribute(in string deviceID, in string key, in string value);

        STI::Types::TChannelSeq getDeviceChannels(in string deviceID);
		boolean setDeviceChannelName(in string deviceID, in short channel, in string name);

        STI::Types::TPartnerSeq getDevicePartners(in string deviceID);

		STI::Types::TLabeledData getLabledData(in string deviceID, in string label);

        boolean deviceStatus(in string deviceID);

		long devicePing(in string deviceID);

		void refreshDevices();
		void stopRefreshing();
		void stopDevice(in string deviceID);
		void killDevice(in string deviceID);
    };

	interface ServerCommandLine
	{
		string executeArgs(in string deviceID, in string args);
		
		boolean writeChannel(in string deviceID, in unsigned short channel, in STI::Types::TValMixed value);
		boolean readChannel(in string deviceID, in unsigned short channel, in STI::Types::TValMixed value, out STI::Types::TDataMixed data);

		STI::Types::TStringSeq registeredPartners(in string deviceID);
		STI::Types::TStringSeq requiredPartners(in string deviceID);
	};

};

};

#endif
