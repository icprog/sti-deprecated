/*! \file
 *  \author Jonathan David Harvey
 *  \author Jason Michael Hogan
 *  \author David Marvin Slaughter Johnson
 *  \author Olaf Mandel
 *  \brief Interface Definition of the Server-Device CORBA communication.
 *  \section license License
 *
 *  Copyright (C) 2008 Jonathan Harvey <harv@stanford.edu>\n
 *  Copyright (C) 2008 Jason Hogan <hogan@stanford.edu>\n
 *  Copyright (C) 2008 David Johnson <dmsj@stanford.edu>\n
 *  Copyright (C) 2008 Olaf Mandel <mandel@stanford.edu>\n
 *  This file is part of Stanford Timing Interface (STI).
 *
 *  STI is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  STI is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with STI.  If not, see <http://www.gnu.org/licenses/>.
 */
#ifndef DEVICE_IDL
#define DEVICE_IDL

#include "orbTypes.idl"
#include "pusher.idl"

module STI
{

module Server_Device
{
	//Server-side
	interface RemoteTrigger
	{
		//The delegated RemoteTrigger calls this function when the rest of the system should play events.
		void trigger();
	};

	//Server-side; reference passed to each device during parsing. Used as a call back hook for the device.
	interface ParsingResultsHandler
	{
		void returnResults(in STI::Types::TDevice device, in STI::Types::TEngineInstance engineInstance, in boolean success, in string errors, in STI::Types::TEventSeq eventsOut);
	};

	//Device-side; server has a reference from each device
	//NetworkEventEngineManager, ORBEventEngineManager
	interface RemoteEventEngineManager
	{
		//Engine lock
		//parse, lock, load, play, unlock, ..., collect
		boolean lock(in STI::Types::TEngineID engineID);
		void unlock(in STI::Types::TEngineID engineID);
		void unlockAll();
	
		//Trigger delegation
		//Device-level trigger support (e.g., for external triggering instead of software triggering by the server)
		//Nothing starts to play until the Trigger initiates play. Server is the Trigger by default.
		void delegateTrigger(in STI::Types::TEngineID engineID, in RemoteTrigger systemTrigger);	//at most one device engine per cycle
		void removeTrigger(in STI::Types::TEngineID engineID);

		//Engine list management
		boolean addEventEngine(in STI::Types::TEngineID engineID);
		boolean hasEngine(in STI::Types::TEngineID engineID);
		void removeAllEngines();
		STI::Types::TEngineIDSeq getEngineIDs();

		//Engine status
		STI::Types::TEventEngineStatus getStatus(in STI::Types::TEngineID engineID);
		STI::Types::TEventEngineState getState(in STI::Types::TEngineID engineID);

		//Engine behavior
		void clear(in STI::Types::TEngineID engineID);	//deletes events, removes the Trigger
		void parse(in STI::Types::TEngineID engineID, in STI::Types::TEventSeq eventsIn, in ParsingResultsHandler results);
		void load(in STI::Types::TEngineID engineID);

		void play(in STI::Types::TEngineInstance engineInstance, in double startTime, in double endTime, in short repeats, in double repeatTime, in STI::Types::TDocumentationOptions docOptions);  //repeats=-1 => infinity?
		void playAll(in STI::Types::TEngineInstance engineInstance, in STI::Types::TDocumentationOptions docOptions);	//plays one complete cycle once
		
		void trigger(in STI::Types::TEngineInstance engineInstance);
		//Actually starts playing events. EventEngines block waiting for the trigger command. 
		//For the RemoteTrigger situation, the server calls this function only on the delegated trigger device, 
		//and it uses the RemoteTrigger to trigger the rest of the system.

		void pause(in STI::Types::TEngineID engineID);
		void pauseAt(in STI::Types::TEngineID engineID, in double time);

		void resume(in STI::Types::TEngineID engineID);
		void resumeAt(in STI::Types::TEngineID engineID, in double newTime);

		void stop(in STI::Types::TEngineID engineID);

		boolean collectData(in STI::Types::TEngineInstance engineInstance, out STI::Types::TMeasurementSeq data);	//false if the data doesn't exist because the EngineInstance didn't run (or is no longer in the buffer).
//		void setDataCollectionBufferDepth(in STI::Types::TEngineID engineID, in short cycles);	//how many TMeasurementSeq's to keep before overwritting the circular buffer; each one collectable by its unique EngineInstance

	};

	//Device-side
	interface DataLogger
	{
		STI::Types::TLogFileSeq getLogFiles();
		void clearLocalLogFiles();
	};


    // Device-side
    interface DeviceConfigure
    {
		void reRegisterWithServer();
		boolean ping();
		void kill();

        // Configurable attributes presented by this device to the server
        readonly attribute STI::Types::TAttributeSeq attributes;
		readonly attribute STI::Types::TChannelSeq channels;
		readonly attribute STI::Types::TPartnerSeq partners;

        boolean setAttribute(in string key, in string value);
        string getAttribute(in string key);

		boolean setDeviceChannelName(in short channel, in string name);
    };

	//Temp
	typedef sequence<RemoteEventEngineManager> RemoteEventEngineManagerSeq;

	//should be renamed Partners
	interface CommandLine
	{
		readonly attribute STI::Types::TStringSeq eventPartnerDevices; //the partners that this device generates event for
		readonly attribute STI::Types::TStringSeq requiredPartnerDevices;
		readonly attribute STI::Types::TStringSeq registeredPartnerDevices;
		readonly attribute STI::Types::TDevice device;

		//executing command line args on partner devices
		string execute(in string args);
        
		//allows devices to set attributes on partner devices
		boolean setAttribute(in string key, in string value);
        string getAttribute(in string key);

		boolean writeChannel(in unsigned short channel, in STI::Types::TValMixed value);
		boolean readChannel(in unsigned short channel, in STI::Types::TValMixed value, out STI::Types::TDataMixed data);	
		//readChannel: 'value' is for (optional) parameters that are needed to make the measurement.  'data' is the result of the measurement

		///RemoteEventEngineManagerSeq is probably wrong below.  What do we need to pass around?
		boolean preparePartnerEvents(in STI::Types::TEventSeq eventsIn, inout RemoteEventEngineManagerSeq partnerControls, inout STI::Types::TStringSeq antecedentDevices);

		boolean registerPartnerDevice(in CommandLine partnerCmdLine);
		boolean unregisterPartnerDevice(in string deviceID);

		STI::Types::TEventSeq getPartnerEvents(in string deviceID);

		boolean ping();
	};


    // Device-side
    interface DataTransfer
    {
        readonly attribute STI::Types::TMeasurementSeq measurements;	//all the measurements

		STI::Types::TMeasurementSeq getRecentMeasurements(in long startingIndex);

		STI::Types::TLabeledData getData(in string dataLabel);
		boolean ping();
    };

	// Device-side
	interface DeviceBootstrap
	{
		boolean ping();
		STI::Types::TDevice getDevice();

		RemoteEventEngineManager getRemoteEventEngineManager();
		DeviceConfigure getDeviceConfigure();
	
		//need work
		CommandLine getCommandLine();
		DataTransfer getDataTransfer();
	};

    // Server object.  Devices establish contact with this (global) object
    interface ServerConfigure
    {
        // Returns true if registration is successful.
        // Asigns a unique TDevice.deviceID for the device.
        // The device uses the deviceID string to specify its attributes to the server.
        // The TDevice.deviceContext is used to register the device with the NameService.
        // This function (in particular, deviceID generation) MUST be thread safe!
        boolean registerDevice(inout STI::Types::TDevice device, in DeviceBootstrap bootstrap);

        boolean removeDevice(in string deviceID);

		//used to generate deviceIDs for partner devices
		string generateDeviceID(in STI::Types::TDevice device);

		STI::Pusher::DeviceEventHandler getDeviceEventHandler();

		boolean ping();

    };



};

};

#endif

